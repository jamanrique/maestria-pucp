<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Dra. Rocío Maehara" />
  <title>Análisis de conglomerados</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="Clase-6_files/reveal.js-3.3.0.1/css/reveal.css"/>



<link rel="stylesheet" href="Clase-6_files/reveal.js-3.3.0.1/css/theme/white.css" id="theme">


  <!-- some tweaks to reveal css -->
  <style type="text/css">
    .reveal h1 { font-size: 2.0em; }
    .reveal h2 { font-size: 1.5em;  }
    .reveal h3 { font-size: 1.25em;	}
    .reveal h4 { font-size: 1em;	}

    .reveal .slides>section,
    .reveal .slides>section>section {
      padding: 0px 0px;
    }



    .reveal table {
      border-width: 1px;
      border-spacing: 2px;
      border-style: dotted;
      border-color: gray;
      border-collapse: collapse;
      font-size: 0.7em;
    }

    .reveal table th {
      border-width: 1px;
      padding-left: 10px;
      padding-right: 25px;
      font-weight: bold;
      border-style: dotted;
      border-color: gray;
    }

    .reveal table td {
      border-width: 1px;
      padding-left: 10px;
      padding-right: 25px;
      border-style: dotted;
      border-color: gray;
    }


  </style>

    <style type="text/css">code{white-space: pre;}</style>

    <link rel="stylesheet" href="logo.css"/>
    <link rel="stylesheet" href="style.css"/>

<!-- Printing and PDF exports -->
<script id="paper-css" type="application/dynamic-css">

/* Default Print Stylesheet Template
   by Rob Glazebrook of CSSnewbie.com
   Last Updated: June 4, 2008

   Feel free (nay, compelled) to edit, append, and
   manipulate this file as you see fit. */


@media print {

	/* SECTION 1: Set default width, margin, float, and
	   background. This prevents elements from extending
	   beyond the edge of the printed page, and prevents
	   unnecessary background images from printing */
	html {
		background: #fff;
		width: auto;
		height: auto;
		overflow: visible;
	}
	body {
		background: #fff;
		font-size: 20pt;
		width: auto;
		height: auto;
		border: 0;
		margin: 0 5%;
		padding: 0;
		overflow: visible;
		float: none !important;
	}

	/* SECTION 2: Remove any elements not needed in print.
	   This would include navigation, ads, sidebars, etc. */
	.nestedarrow,
	.controls,
	.fork-reveal,
	.share-reveal,
	.state-background,
	.reveal .progress,
	.reveal .backgrounds {
		display: none !important;
	}

	/* SECTION 3: Set body font face, size, and color.
	   Consider using a serif font for readability. */
	body, p, td, li, div {
		font-size: 20pt!important;
		font-family: Georgia, "Times New Roman", Times, serif !important;
		color: #000;
	}

	/* SECTION 4: Set heading font face, sizes, and color.
	   Differentiate your headings from your body text.
	   Perhaps use a large sans-serif for distinction. */
	h1,h2,h3,h4,h5,h6 {
		color: #000!important;
		height: auto;
		line-height: normal;
		font-family: Georgia, "Times New Roman", Times, serif !important;
		text-shadow: 0 0 0 #000 !important;
		text-align: left;
		letter-spacing: normal;
	}
	/* Need to reduce the size of the fonts for printing */
	h1 { font-size: 28pt !important;  }
	h2 { font-size: 24pt !important; }
	h3 { font-size: 22pt !important; }
	h4 { font-size: 22pt !important; font-variant: small-caps; }
	h5 { font-size: 21pt !important; }
	h6 { font-size: 20pt !important; font-style: italic; }

	/* SECTION 5: Make hyperlinks more usable.
	   Ensure links are underlined, and consider appending
	   the URL to the end of the link for usability. */
	a:link,
	a:visited {
		color: #000 !important;
		font-weight: bold;
		text-decoration: underline;
	}
	/*
	.reveal a:link:after,
	.reveal a:visited:after {
		content: " (" attr(href) ") ";
		color: #222 !important;
		font-size: 90%;
	}
	*/


	/* SECTION 6: more reveal.js specific additions by @skypanther */
	ul, ol, div, p {
		visibility: visible;
		position: static;
		width: auto;
		height: auto;
		display: block;
		overflow: visible;
		margin: 0;
		text-align: left !important;
	}
	.reveal pre,
	.reveal table {
		margin-left: 0;
		margin-right: 0;
	}
	.reveal pre code {
		padding: 20px;
		border: 1px solid #ddd;
	}
	.reveal blockquote {
		margin: 20px 0;
	}
	.reveal .slides {
		position: static !important;
		width: auto !important;
		height: auto !important;

		left: 0 !important;
		top: 0 !important;
		margin-left: 0 !important;
		margin-top: 0 !important;
		padding: 0 !important;
		zoom: 1 !important;

		overflow: visible !important;
		display: block !important;

		text-align: left !important;
		-webkit-perspective: none;
		   -moz-perspective: none;
		    -ms-perspective: none;
		        perspective: none;

		-webkit-perspective-origin: 50% 50%;
		   -moz-perspective-origin: 50% 50%;
		    -ms-perspective-origin: 50% 50%;
		        perspective-origin: 50% 50%;
	}
	.reveal .slides section {
		visibility: visible !important;
		position: static !important;
		width: auto !important;
		height: auto !important;
		display: block !important;
		overflow: visible !important;

		left: 0 !important;
		top: 0 !important;
		margin-left: 0 !important;
		margin-top: 0 !important;
		padding: 60px 20px !important;
		z-index: auto !important;

		opacity: 1 !important;

		page-break-after: always !important;

		-webkit-transform-style: flat !important;
		   -moz-transform-style: flat !important;
		    -ms-transform-style: flat !important;
		        transform-style: flat !important;

		-webkit-transform: none !important;
		   -moz-transform: none !important;
		    -ms-transform: none !important;
		        transform: none !important;

		-webkit-transition: none !important;
		   -moz-transition: none !important;
		    -ms-transition: none !important;
		        transition: none !important;
	}
	.reveal .slides section.stack {
		padding: 0 !important;
	}
	.reveal section:last-of-type {
		page-break-after: avoid !important;
	}
	.reveal section .fragment {
		opacity: 1 !important;
		visibility: visible !important;

		-webkit-transform: none !important;
		   -moz-transform: none !important;
		    -ms-transform: none !important;
		        transform: none !important;
	}
	.reveal section img {
		display: block;
		margin: 15px 0px;
		background: rgba(255,255,255,1);
		border: 1px solid #666;
		box-shadow: none;
	}

	.reveal section small {
		font-size: 0.8em;
	}

}  
</script>


<script id="pdf-css" type="application/dynamic-css">
    
/**
 * This stylesheet is used to print reveal.js
 * presentations to PDF.
 *
 * https://github.com/hakimel/reveal.js#pdf-export
 */

* {
	-webkit-print-color-adjust: exact;
}

body {
	margin: 0 auto !important;
	border: 0;
	padding: 0;
	float: none !important;
	overflow: visible;
}

html {
	width: 100%;
	height: 100%;
	overflow: visible;
}

/* Remove any elements not needed in print. */
.nestedarrow,
.reveal .controls,
.reveal .progress,
.reveal .playback,
.reveal.overview,
.fork-reveal,
.share-reveal,
.state-background {
	display: none !important;
}

h1, h2, h3, h4, h5, h6 {
	text-shadow: 0 0 0 #000 !important;
}

.reveal pre code {
	overflow: hidden !important;
	font-family: Courier, 'Courier New', monospace !important;
}

ul, ol, div, p {
	visibility: visible;
	position: static;
	width: auto;
	height: auto;
	display: block;
	overflow: visible;
	margin: auto;
}
.reveal {
	width: auto !important;
	height: auto !important;
	overflow: hidden !important;
}
.reveal .slides {
	position: static;
	width: 100%;
	height: auto;

	left: auto;
	top: auto;
	margin: 0 !important;
	padding: 0 !important;

	overflow: visible;
	display: block;

	-webkit-perspective: none;
	   -moz-perspective: none;
	    -ms-perspective: none;
	        perspective: none;

	-webkit-perspective-origin: 50% 50%; /* there isn't a none/auto value but 50-50 is the default */
	   -moz-perspective-origin: 50% 50%;
	    -ms-perspective-origin: 50% 50%;
	        perspective-origin: 50% 50%;
}

.reveal .slides section {
	page-break-after: always !important;

	visibility: visible !important;
	position: relative !important;
	display: block !important;
	position: relative !important;

	margin: 0 !important;
	padding: 0 !important;
	box-sizing: border-box !important;
	min-height: 1px;

	opacity: 1 !important;

	-webkit-transform-style: flat !important;
	   -moz-transform-style: flat !important;
	    -ms-transform-style: flat !important;
	        transform-style: flat !important;

	-webkit-transform: none !important;
	   -moz-transform: none !important;
	    -ms-transform: none !important;
	        transform: none !important;
}

.reveal section.stack {
	margin: 0 !important;
	padding: 0 !important;
	page-break-after: avoid !important;
	height: auto !important;
	min-height: auto !important;
}

.reveal img {
	box-shadow: none;
}

.reveal .roll {
	overflow: visible;
	line-height: 1em;
}

/* Slide backgrounds are placed inside of their slide when exporting to PDF */
.reveal section .slide-background {
	display: block !important;
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	z-index: -1;
}

/* All elements should be above the slide-background */
.reveal section>* {
	position: relative;
	z-index: 1;
}

/* Display slide speaker notes when 'showNotes' is enabled */
.reveal .speaker-notes-pdf {
	display: block;
	width: 100%;
	max-height: none;
	left: auto;
	top: auto;
	z-index: 100;
}

/* Display slide numbers when 'slideNumber' is enabled */
.reveal .slide-number-pdf {
	display: block;
	position: absolute;
	font-size: 14px;
}

</script>


<script>
var style = document.createElement( 'style' );
style.type = 'text/css';
var style_script_id = window.location.search.match( /print-pdf/gi ) ? 'pdf-css' : 'paper-css';
var style_script = document.getElementById(style_script_id).text;
style.innerHTML = style_script;
document.getElementsByTagName('head')[0].appendChild(style);
</script>

</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title"><strong>Análisis de conglomerados</strong></h1>
    <h2 class="author">Dra. Rocío Maehara</h2>
    <h3 class="date">23 de noviembre de 2019 <br> <img id='logopucp' src='logoPUCP.jpg'></h3>
</section>

<section id="introducción" class="slide level2">
<h2>Introducción</h2>
<div align="justify">
<p>Supóngase que el responsable de marketing de una empresa tiene una base de datos con las <span style="color:red">características sociodemográficas de sus clientes</span>: <span style="color:blue">edad</span>, <span style="color:blue">nivel educativo</span>, <span style="color:blue">nivel de ingresos</span>, <span style="color:blue">estado civil</span>, <span style="color:blue">tipo de ocupación</span>, <span style="color:blue">número de hijos</span>, etc. <br> Este directivo se plantea si podría <span style="color:green">dividir a sus clientes en subgrupos</span>, que tuvieran <span style="color:green">características sociodemográficas similares entre sí</span>, pero que <span style="color:brown">unos subgrupos de otros</span>, fueran <span style="color:brown">lo más diferentes posibles</span>.</p>
</div>
</section>
<section id="introducción-1" class="slide level2">
<h2>Introducción</h2>
<div align="justify">
<p>Si esto fuera posible, el directivo de marketing podría, por ejemplo, <span style="color:blue">diseñar campañas de publicidad distintas para cada grupo</span>, con <span style="color:green">creatividades diferentes</span> o <span style="color:brown">utilizando diarios, revistas o cadenas de televisión distintas</span> según el grupo al que fuera dirigida la campaña.</p>
</div>
</section>
<section id="introducción-2" class="slide level2">
<h2>Introducción</h2>
<div align="justify">
<p>
<p>E] análisis de conglomerados, al que también se denomina comúnmente análisis cluster, es una técnica diseñada para clasificar distintas observaciones en grupos, de tal forma que:</p>
<ul>
<li><p>Cada grupo (conglomerado o cluster) sea homogéneo respecto a las variables utilizadas para caracterizarlo, es decir, que cada observación contenida en él sea parecida a todas las que estén incluidas en ese grupo.</p></li>
<li>Que los grupos sean lo más distintos posible unos de otros respecto a las variables consideradas.</li>
</ul>
</p>
</div>
</section>
<section id="introducción-3" class="slide level2">
<h2>Introducción</h2>
<div align="justify">
<p>Es importante señalar, para distinguir el análisis de conglomerados de otras técnicas tratadas anteriormente, que los grupos son desconocidos a priori y es necesario derivarlos de las observaciones. En el análisis discriminante o la regresión logística, por ejemplo, las observaciones ya estan previamente clasificadas en dos o más grupos, buscándose las razones que explican esa clasificación y no la clasificación en sí.</p>
</div>
</section>
<section id="proceso-del-análisis-de-conglomerados" class="slide level2">
<h2>Proceso del análisis de conglomerados</h2>
<div id="left">
<p><img src="images/proc_congl.JPG" width="100%" /></p>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
<ul>
<li><p>Inicialmente, el investigador dispone de <span class="math inline">\(n\)</span> observaciones (individuos, empresas, etc.) de las que tiene información sobre <span class="math inline">\(k\)</span> variables (edad, estado civil, número de hijos…).</p></li>
<li>A continuación, se establece un indicador que nos diga en qué medida cada par de observaciones se parece entre sí. A esta medida se la denomina distancia o (di)similaridad.</li>
</ul>
</p>
<p></font></p>
</div>
</div>
</section>
<section id="proceso-del-análisis-de-conglomerados-1" class="slide level2">
<h2>Proceso del análisis de conglomerados</h2>
<div id="left">
<p><img src="images/proc_congl.JPG" width="100%" /></p>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
<ul>
<li>Consiste en hacer grupos con aquellas observaciones que mas se parezcan entre sí, de acuerdo con la medida de similaridad calculada anteriormente. Ello exige elegir entre los dos tipos de análisis de conglomerados: jerárquico y no jerárquico y el método de conglomeración para el tipo de análisis elegido (centroide o vecino mas cercano, entre otros, en el conglomerado jerárquico).</li>
</ul>
</p>
<p></font></p>
</div>
</div>
</section>
<section id="proceso-del-análisis-de-conglomerados-2" class="slide level2">
<h2>Proceso del análisis de conglomerados</h2>
<div id="left">
<p><img src="images/proc_congl.JPG" width="100%" /></p>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
<ul>
<li>Finalmente, el investigador debe describir los grupos que ha obtenido y comparar los unos con los otros. Para ello bastará con ver qué valores promedio toman las <span class="math inline">\(k\)</span> variables utilizadas en el análisis de conglomerados en cada uno de los <span class="math inline">\(g\)</span> grupos obtenidos (<span class="math inline">\(g &lt; n\)</span>).</li>
</ul>
</p>
<p></font></p>
</div>
</div>
</section>
<section id="ejemplo" class="slide level2">
<h2>Ejemplo</h2>
<div align="justify">
<p><strong>Relación entre la publicidad y las ventas </strong> <br> Supongamos que un investigador tiene información del presupuesto que un conjunto de empresas ha destinado a publicidad el ultimo año y de las ventas que han logrado. Puede preguntarse si estas empresas pueden agruparse en función de la rentabilidad en términos de ventas que han sido capaces de generar con su inversión publicitaria.</p>
</div>
</section>
<section id="ejemplo-1" class="slide level2">
<h2>Ejemplo</h2>
<div align="justify">
<p><strong>Relación entre la publicidad y las ventas </strong> <br> Por ejemplo, el investigador puede examinar si existe un grupo de empresas que, invirtiendo en publicidad relativamente poco, ha logrado una elevada cifra de ventas o, por el contrario, si existe un grupo que, aun invirtiendo mucho en publicidad, no ha sido capaz de vender tanto como sus competidoras. En definitiva, ¿qué tipologia de empresas puede establecerse en función de la rentabilidad obtenida de su inversión publicitaria?</p>
</div>
</section>
<section id="ejemplo-2" class="slide level2">
<h2>Ejemplo</h2>
<div align="justify">
<pre><code>Empresa &lt;- c(&quot;E1&quot;,&quot;E2&quot;,&quot;E3&quot;,&quot;E4&quot;,&quot;E5&quot;,&quot;E6&quot;,&quot;E7&quot;,&quot;E8&quot;)
Inversion_publicitaria &lt;- c(16,12,10,12,45,50,45,50)
Ventas &lt;- c(10,14,22,25,10,15,25,27)
datos &lt;- data.frame(Inversion_publicitaria,Ventas)
attach(datos)
row.names(datos)&lt;-Empresa
plot(Inversion_publicitaria,Ventas,pch=16,xlab=&quot;Inversión&quot;,ylab=&quot;Ventas&quot;,xlim=c(5,60),ylim=c(5,30))
with(datos, text(Ventas~Inversion_publicitaria, labels = row.names(datos), pos = 4))
</code></pre>
</div>
</section>
<section id="ejemplo-3" class="slide level2">
<h2>Ejemplo</h2>
<div id="left">
<p><img src="Clase-6_files/figure-revealjs/unnamed-chunk-4-1.png" width="768" /></p>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
<p>Al haber utilizado solo dos variables en el ejemplo planteado, este gráfico permite responder de una manera intuitiva a las preguntas que se hace el investigador. A la vista de este gráfico pueden distinguirse cuatro grupos de empresas:</p>
<ul>
<li>El grupo formado porlas empresas E1 y E2, que, con una pequeña inversión en publicidad, han obtenido también pocas ventas.</li>
</ul>
</p>
<p></font></p>
</div>
</div>
</section>
<section id="ejemplo-4" class="slide level2">
<h2>Ejemplo</h2>
<div id="left">
<p><img src="Clase-6_files/figure-revealjs/unnamed-chunk-5-1.png" width="768" /></p>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
<ul>
<li>El grupo formado por las empresas E3 y E4, que, pese a haber invertido tan poco como las empresas del grupo anterior, han obtenido una gran rentabilidad en términos de ventas a estas inversiones.</li>
<li>El grupo formado por las empresas E5 y E6, que, pese a haber efectuado un gran esfuerzo publicitario, no han sido capaces de obtener unas ventas razonables.</li>
</ul>
</p>
<p></font></p>
</div>
</div>
</section>
<section id="ejemplo-5" class="slide level2">
<h2>Ejemplo</h2>
<div id="left">
<p><img src="Clase-6_files/figure-revealjs/unnamed-chunk-6-1.png" width="768" /></p>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
<ul>
<li>El grupo formado por las empresas E7 y E8, que, con inversiones también elevadas, si que han logrado, por el contrario, rentabilizar su inversión en términos de ventas.</li>
</ul>
<p>¿Cómo se han obtenido los grupos anteriores? De una manera intuitiva hemos visto, por ejemplo, que la empresa E1 esta a una distancia menor de E2 que de E3 o que de cualquiera de las empresas restantes, y las hemos puesto en un mismo grupo.</p>
</p>
<p></font></p>
</div>
</div>
</section>
<section id="ejemplo-6" class="slide level2">
<h2>Ejemplo</h2>
<div id="left">
<p><img src="Clase-6_files/figure-revealjs/unnamed-chunk-7-1.png" width="768" /></p>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
De manera análoga, e igualmente intuitiva, hemos procedido con las demas empresas, llegando a la solución de cuatro grupos expuesta. Pero ¿qué hubiera ocurrido si en lugar de dos variables pretendiésemos llevar a cabo agrupaciones de observaciones teniendo en cuenta 5, 10 o 50 variables?
</p>
<p></font></p>
</div>
</div>
</section>
<section id="ejemplo-7" class="slide level2">
<h2>Ejemplo</h2>
<div id="left">
<p><img src="Clase-6_files/figure-revealjs/unnamed-chunk-8-1.png" width="768" /></p>
</div>
<div id="right">
<div align="justify">
<font size="5.99">
<p class="small">
<p>La intuición debe dejar paso a la formalización. Sin embargo, ilustraremos el proceso que sigue el análisis de conglomerados con este ejemplo sencillo para, finalmente, aplicarlo a una situación más real en el último epígrafe del capítulo. <br></p>
<p>Lo primero que se ha hecho de manera intuitiva es ver que E1 esta mas cerca de E2 que de E3. Este “más cerca” se traduce en el análisis de conglomerados en el cálculo de alguna medida de proximidad o similaridad entre cada par de observaciones.</p>
</p>
<p></font></p>
</div>
</div>
</section>
<section id="medidas-de-similaridad-para-variables-métricas" class="slide level2">
<h2>Medidas de similaridad para variables métricas</h2>
<div align="justify">
<p><font size="6"> En el caso en que las variables que se utilizan para caracterizar las observaciones sean métricas, es decir, de intervalo o de razón, se puede recurrir a cualquiera de las siguientes medidas de similaridad.<br> <strong>Distancia euclídea</strong> <br> Si consideramos dos observaciones <span class="math inline">\(i\)</span> y <span class="math inline">\(j\)</span> de las <span class="math inline">\(n\)</span> posibles y si llamamos <span class="math inline">\(x_{ip}\)</span> y <span class="math inline">\(x_{jp}\)</span> al valor que toma la variable <span class="math inline">\(x_p\)</span>, de las <span class="math inline">\(k\)</span> existentes en dichas observaciones, la distancia euclídea <span class="math inline">\(D_{ij}\)</span> entre ambas se calcularia del siguiente modo: <span class="math display">\[D_{ij}=\sqrt{\sum_{p=1}^{k}(x_{ip}-x_{jp})^2}\]</span> </font></p>
</div>
</section>
<section id="medidas-de-similaridad-para-variables-métricas-1" class="slide level2">
<h2>Medidas de similaridad para variables métricas</h2>
<div id="left">
<pre><code>datos</code></pre>
<pre><code>##    Inversion_publicitaria Ventas
## E1                     16     10
## E2                     12     14
## E3                     10     22
## E4                     12     25
## E5                     45     10
## E6                     50     15
## E7                     45     25
## E8                     50     27</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
<p>asi, por ejemplo, la distancia euclidea entre las empresas E1 y E2 tomael valor siguiente:</p>
<p><span class="math display">\[D_{12}=\sqrt{(16-12)^2+(10-14)^2}=5.66\]</span> que es menor que la distancia existente entre las empresas E1 y E3:</p>
<p><span class="math display">\[D_{13}=\sqrt{(16-10)^2+(10-22)^2}=13.42\]</span></p>
</p>
<p></font></p>
</div>
</div>
</section>
<section id="ejemplo-8" class="slide level2">
<h2>Ejemplo</h2>
<div id="left">
<pre><code># Distancia euclidiana
matriz.dis.euclid &lt;- dist(datos[,1:2],method=&quot;euclidian&quot;,diag=TRUE)
round(matriz.dis.euclid,2)
</code></pre>
<pre><code>##       E1    E2    E3    E4    E5    E6    E7    E8
## E1  0.00                                          
## E2  5.66  0.00                                    
## E3 13.42  8.25  0.00                              
## E4 15.52 11.00  3.61  0.00                        
## E5 29.00 33.24 37.00 36.25  0.00                  
## E6 34.37 38.01 40.61 39.29  7.07  0.00            
## E7 32.65 34.79 35.13 33.00 15.00 11.18  0.00      
## E8 38.01 40.16 40.31 38.05 17.72 12.00  5.39  0.00</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
La mayoria de algoritmos calculan las distancias entre todos los pares de observaciones, como paso inicial del análisis de conglomerados. Mostramos la matriz euclidiana obtenida con el R con la función <code>dis()</code>
</p>
<p></font></p>
</div>
</div>
</section>
<section id="medidas-de-similaridad-para-variables-métricas-2" class="slide level2">
<h2>Medidas de similaridad para variables métricas</h2>
<div align="justify">
<p><font size="6"> <strong>Distancia de Minkowski</strong> <br> Las distancia euclídea y distancia eucídea al cuadrado son un caso particular de la distancia de Minkowski, que viene dada porla expresión: <span class="math display">\[D_{ij}=[\sum_{p=1}^{k}|x_{ip}-x_{jp}|^n]^{1/n}\]</span> Puede comprobarse que haciendo <span class="math inline">\(n = 2\)</span> se obtiene la expresién correspondiente a la distancia euclídea. </font></p>
</div>
</section>
<section id="medidas-de-similaridad-para-variables-métricas-3" class="slide level2">
<h2>Medidas de similaridad para variables métricas</h2>
<div align="justify">
<p><font size="6"> <strong>Distancia city block o “Manhattan”</strong> <br> Si en la expresion de la distancia de Minkowski tomaramos <span class="math inline">\(n = 1\)</span>, obtendríamos la denominada distancia city block, la cuál viene dada por: <span class="math display">\[D_{ij}=\sum_{p=1}^{k}|x_{ip}-x_{jp}|\]</span> </font></p>
</div>
</section>
<section id="estandarización-de-los-datos" class="slide level2">
<h2>Estandarización de los datos</h2>
<div align="justify">
<p><font size="6"> Si se analizan con detenimiento las medidas de distancia presentadas, se puede comprobar que todas ellas estén basadas en la sustracción, para cada par de observaciones, de los valores de las variables utilizadas en su caracterización. Por ello, se puede esperar que las medidas de disimilaridad sean muy sensibles a las unidades en que estén medidas dichas variables. Si pretendemos agrupar empresas en función de dos variables, como el tamaño de su activos medido en pesetas y el número de trabajadores, la primera variable contribuirá mucho mas a establecer los grupos que la segunda. Y esto no se debe a que conceptualmente una sea mucho mas importante que la otra, sino a que, con esas unidades, su valor absoluto será siempre muy superior. </font></p>
</div>
</section>
<section id="estandarización-de-los-datos-1" class="slide level2">
<h2>Estandarización de los datos</h2>
<div id="left">
<pre><code>nombre.empresa2&lt;-c(&quot;E1&quot;,&quot;E2&quot;,&quot;E3&quot;,&quot;E4&quot;,&quot;E5&quot;,&quot;E6&quot;,&quot;E7&quot;,&quot;E8&quot;)
activos&lt;-c(10.0e9,10.5e9,10.0e9,10.5e9,20.0e9,20.5e9,20.0e9,20.5e9)
trabajadores&lt;-c(100,90,200,190,200,190,100,90)
Datos_EST&lt;-data.frame(nombre.empresa2,activos,trabajadores)
Datos_EST
</code></pre>
<pre><code>##   nombre.empresa2  activos trabajadores
## 1              E1 1.00e+10          100
## 2              E2 1.05e+10           90
## 3              E3 1.00e+10          200
## 4              E4 1.05e+10          190
## 5              E5 2.00e+10          200
## 6              E6 2.05e+10          190
## 7              E7 2.00e+10          100
## 8              E8 2.05e+10           90</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="5.99">
<p class="small">
Los datos presentados recogen el tamaño de los activos y el número de trabajadores de ocho empresas hipotéticas. Si efectuamos un análisis de conglomerados con las unidades originales, la matriz de distancias mostrará que los dos grupos obtenidos responden exclusivamente a la variable “activos de la empresa”, puesto que sitúa en un mismo grupo a aquellas con cifras que rondan los 10000 millones de pesetas (E1, E2, E3 y E4) y en otro grupo a las que tienen activos en torno a los 20000 millones (E5, E6, E7 y E8).
</p>
<p></font></p>
</div>
</div>
</section>
<section id="estandarización-de-los-datos-2" class="slide level2">
<h2>Estandarización de los datos</h2>
<div id="left">
<pre><code>matriz.dis.euclid2&lt;-dist(Datos_SEST[,c(&quot;activos&quot;,&quot;trabajadores&quot;)],method=&quot;euclidean&quot;,diag=TRUE)
matriz.dis.euclid2
</code></pre>
<pre><code>##          1        2        3        4        5        6        7        8
## 1 0.00e+00                                                               
## 2 5.00e+08 0.00e+00                                                      
## 3 1.00e+02 5.00e+08 0.00e+00                                             
## 4 5.00e+08 1.00e+02 5.00e+08 0.00e+00                                    
## 5 1.00e+10 9.50e+09 1.00e+10 9.50e+09 0.00e+00                           
## 6 1.05e+10 1.00e+10 1.05e+10 1.00e+10 5.00e+08 0.00e+00                  
## 7 1.00e+10 9.50e+09 1.00e+10 9.50e+09 1.00e+02 5.00e+08 0.00e+00         
## 8 1.05e+10 1.00e+10 1.05e+10 1.00e+10 5.00e+08 1.00e+02 5.00e+08 0.00e+00</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="5.99">
<p class="small">
Es decir, la influencia del número de trabajadores en la obtención de estos conglomerados es practicamente nula. Para evitar esta influencia no deseable de una variable debida exclusivamente a la unidad en que viene medida es necesario corregir el efecto de los datos recurriendo a un proceso de estandarización.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="estandarización-de-los-datos-3" class="slide level2">
<h2>Estandarización de los datos</h2>
<div align="justify">
<p><font size="6"> <strong>Puntuaciones Z</strong> <br> Los datos son estandarizados, restando al valor de cada observación de una variable determinada,la media de esa variable para el conjunto de las observaciones y dividiendo el resultado por su desviación típica. De esta forma la variable estandarizada tiene media 0, y desviación típica, 1. <br> <strong>Rango 1</strong> <br> El valor de una variable dada en cada observación es dividido por el rango de esa variable para el conjunto de observaciones. De esta forma el rango de variación de la variable así estandarizada queda reducido a un intervalo de valor 1. </font></p>
</div>
</section>
<section id="estandarización-de-los-datos-4" class="slide level2">
<h2>Estandarización de los datos</h2>
<div align="justify">
<p><strong>Rango 0 a 1</strong> <br> El valor de una variable determinada para cada observación es estandarizada sustrayéndole el valor mínimo que toma esa variable en el conjunto de las observaciones y a continuación dividiendo por el rango. De esta forma el valor mínimo de las variables sera 0, y el máximo, 1.</p>
</div>
</section>
<section id="estandarización-de-los-datos-5" class="slide level2">
<h2>Estandarización de los datos</h2>
<div id="left">
<pre><code>Datos_EST&lt;-scale(Datos_SEST[,c(&quot;activos&quot;,&quot;trabajadores&quot;)])
matriz.dis.euclid.norm&lt;-dist(Datos_EST[,c(&quot;activos&quot;,&quot;trabajadores&quot;)],method=&quot;euclidean&quot;,diag=TRUE)
round(matriz.dis.euclid.norm,2)
</code></pre>
<pre><code>##      1    2    3    4    5    6    7    8
## 1 0.00                                   
## 2 0.21 0.00                              
## 3 1.86 2.05 0.00                         
## 4 1.68 1.86 0.21 0.00                    
## 5 2.64 2.71 1.87 1.78 0.00               
## 6 2.58 2.64 1.97 1.87 0.21 0.00          
## 7 1.87 1.78 2.64 2.44 1.86 1.68 0.00     
## 8 1.97 1.87 2.84 2.64 2.05 1.86 0.21 0.00</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="5.99">
<p class="small">
Veamos si estandarizando los datos del ejemplo mediante el procedimiento de las puntuaciones Z, se logra corregir la influencia desproporcionada de la variable activos de la empresa en la formación de los grupos. Usaremos para ello la función <code>scale{base}</code>.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="estandarización-de-los-datos-6" class="slide level2">
<h2>Estandarización de los datos</h2>
<div id="left">
<p><img src="images/dist_est.JPG" width="100%" /></p>
<p><img src="images/empresa.JPG" width="100%" /></p>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
Ahora aparecen cuatro grupos formados por dos empresas que se parecen mucho entre sí. Asi, el formado por E1 y E2 tienen activos en torno a los 10.000 millones, pero los separa del grupo formado por E3 y E4 el hecho de que estas últimas empresas les doblan en términos de número de trabajadores. Se observa como, estandarizando los datos, se elimina el efecto de las unidades de medida y las dos variables que caracterizan las observaciones tienen el mismo peso a la hora de formar los grupos.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="formación-de-los-grupos" class="slide level2">
<h2>Formación de los grupos</h2>
<div align="justify">
<p><font size="6"> Los algoritmos de agrupación existentes responden a dos grandes enfoques:<br> <strong>Métodos jerárquicos:</strong> Existen dos enfoques <br> * <em>Métodos jerárquicos aglomerativos</em>: inicialmente cada individuo es un grupo en sí mismo. Sucesivamente se van formando grupos de mayor tamaño fusionando grupos cercanos entre sí. Finalmente, todos los individuos confluyen en un solo grupo.</p>
<ul>
<li><em>Métodos jerarquicos desagregativos</em>: inicialmente, todos los individuos forman un único grupo y se van sucesivamente desgajando de él, formando dos grupos, tres grupos y asi hasta que al final del proceso cada caso forma un único grupo.</li>
</ul>
<p>La mayoría de paquetes estadísticos usan el primer enfoque.</p>
<p></font></p>
</div>
</section>
<section id="principales-algoritmos-de-agrupamiento-jerárquico" class="slide level2">
<h2>Principales algoritmos de agrupamiento jerárquico</h2>
<div align="justify">
<p><font size="6"> <strong>Método del centroide</strong> <br></p>
<ul>
<li>Está implementado en la función de <code>R</code>, <code>hclust{stats}</code>.</li>
<li>En primer lugar, se calcula la matriz de distancias, en este caso euclidea al cuadrado, entre las ocho empresas usando el siguiente código de R. </font></li>
</ul>
<pre><code>library(stats)
#calculo de la distancia euclídea
matriz.dis.euclid&lt;-dist(datos[,c(&quot;Inversion_publicitaria&quot;,&quot;Ventas&quot;)],method=&quot;euclidean&quot;,diag=TRUE)

#calculo de la distancia euclidea al cuadrado
matriz.dis.euclid2&lt;-(matriz.dis.euclid)^2
matriz.dis.euclid2</code></pre>
</div>
</section>
<section id="método-del-centroide" class="slide level2">
<h2>Método del centroide</h2>
<div id="left">
<pre><code>##      E1   E2   E3   E4   E5   E6   E7   E8
## E1    0                                   
## E2   32    0                              
## E3  180   68    0                         
## E4  241  121   13    0                    
## E5  841 1105 1369 1314    0               
## E6 1181 1445 1649 1544   50    0          
## E7 1066 1210 1234 1089  225  125    0     
## E8 1445 1613 1625 1448  314  144   29    0</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
<ul>
<li>Se puede apreciar la matriz de distancias euclídeas al cuadrado.</li>
<li>En esta matriz se puede apreciar que las empresas más cercanas son E3 y E4.</li>
</ul>
</p>
<p></font></p>
</div>
</div>
</section>
<section id="método-del-centroide-1" class="slide level2">
<h2>Método del centroide</h2>
<div id="left">
<pre><code>#efectuamos el cluster con método centroide
hclust.centroide&lt;-hclust(matriz.dis.euclid2,method=&quot;centroid&quot;)

#Saca el historial de aglomeración del objeto hclust.centroide
data.frame(hclust.centroide[2:1])</code></pre>
<pre><code>##    height merge.1 merge.2
## 1   13.00      -3      -4
## 2   29.00      -7      -8
## 3   32.00      -1      -2
## 4   50.00      -5      -6
## 5  141.25       1       3
## 6  182.25       2       4
## 7 1227.25       5       6</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="5.99">
<p class="small">
<ul>
<li>Pues bien, el método del centroide comienza uniendo aquellas dos observaciones que estén més cercanas, en este caso las empresas E3 y E4 (la distancia es 13).</li>
<li>A continuación el grupo formado es sustituido por una observación que lo representa y en la que las variables toman los valores medios de todas las observaciones que constituyen el grupo representado (centroide).</li>
<li>En nuestro ejemplo, las empresas E3 y E4 son sustituidas por una empresa promedio, que</li>
</ul>
</p>
<p></font></p>
</div>
</div>
</section>
<section id="método-del-centroide-2" class="slide level2">
<h2>Método del centroide</h2>
<div id="left">
<pre><code>datos</code></pre>
<pre><code>##    Inversion_publicitaria Ventas
## E1                     16     10
## E2                     12     14
## E3                     10     22
## E4                     12     25
## E5                     45     10
## E6                     50     15
## E7                     45     25
## E8                     50     27</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="5.9">
<p class="small">
En nuestro ejemplo, las empresas E3 y E4 son sustituidas por una empresa promedio, que llamaremos E3-4, para la que el gasto en publicidad y las ventas toman los siguientes valores: <span class="math display">\[Publicidad-E3-4=\frac{10+12}{2}=11\]</span> <span class="math display">\[Ventas-E3-4=\frac{22+25}{2}=23.5\]</span> En ese momento se recalcula la matriz de distancias, solo que, en lugar de estar presentes las empresas E3 y E4, esta su centroide E3-4.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="método-del-centroide-3" class="slide level2">
<h2>Método del centroide</h2>
<div id="left">
<pre><code>#efectuamos el cluster con método centroide
hclust.centroide&lt;-hclust(matriz.dis.euclid2,method=&quot;centroid&quot;)

#Saca el historial de aglomeración del objeto hclust.centroide
data.frame(hclust.centroide[2:1])</code></pre>
<pre><code>##    height merge.1 merge.2
## 1   13.00      -3      -4
## 2   29.00      -7      -8
## 3   32.00      -1      -2
## 4   50.00      -5      -6
## 5  141.25       1       3
## 6  182.25       2       4
## 7 1227.25       5       6</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
<ul>
<li><code>hclust</code> muestra esas distancias sucesivas en lo que denominamos el historial de conglomeración.</li>
<li>En el paso 5 se fusionan las empresas que lo hicieron en el paso 1 (E3-4) con las quelo hicieron en el paso 3 (E1-2).</li>
<li>El proceso termina cuando todas las empresas estan en un solo grupo.</li>
</ul>
</p>
<p></font></p>
</div>
</div>
</section>
<section id="método-del-centroide-4" class="slide level2">
<h2>Método del centroide</h2>
<div id="left">
<pre><code>#dendograma centroide
plot.hclust&lt;-plot(hclust.centroide)
rect.hclust(hclust.centroide, k = 2, border = &quot;red&quot;)</code></pre>
<p><img src="Clase-6_files/figure-revealjs/unnamed-chunk-20-1.png" width="768" /></p>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
<ul>
<li>El historial de conglomeración tiene una traducción gráfica que es de gran utilidad para determinar el número razonable de grupos que debe retenerse.</li>
<li>A este gráfico se le denomina <em>dendograma</em>.</li>
<li>Obsérvese como los grupos que se formaron en la etapa 5 (empresas 3, 4, 1 y 2) y los que se formaron en la 6 (7, 8, 5 y 6) estan a tal distancia que no es razonable fusionarlos. Esos dos grupos son los que el analista deberia retener.</li>
</ul>
</p>
<p></font></p>
</div>
</div>
</section>
<section id="método-del-vecino-más-cercano" class="slide level2">
<h2>Método del vecino más cercano</h2>
<div align="justify">
<font size="6">
<p>
<ul>
<li><p>En algunos textos aparece también bajo la etiqueta de vinculación simple single linkage, la distancia entre dos grupos es aquella que se da entre los dos miembros mas cercanos de esos grupos.</p></li>
<li>Para realizar en R la metología del vecino más cercano se usaran los siguientes comandos para obtener el historial de aglomeración:</li>
</ul>
</p>
<p></font></p>
</div>
<pre><code>#efectuamos el cluster con método centroide con método del vecino más cercano
hclust.cercano&lt;-hclust(matriz.dis.euclid2,method=&quot;single&quot;)
#Saca el historial de aglomeración del objeto hclust.centroide
data.frame(hclust.cercano[2:1])</code></pre>
</section>
<section id="método-del-vecino-más-cercano-1" class="slide level2">
<h2>Método del vecino más cercano</h2>
<div id="left">
<p><img src="images/vecinocercano.JPG" width="100%" /></p>
<pre><code>##   height merge.1 merge.2
## 1     13      -3      -4
## 2     29      -7      -8
## 3     32      -1      -2
## 4     50      -5      -6
## 5     68       1       3
## 6    125       2       4
## 7    841       5       6</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
<ul>
<li><p>La distancia entre los grupos E1-2 y E3-4 estará representada por la distancia entre E2 y E3, que son los mas cercanos (68 unidades, puesto que E1 dista 180 unidades de E3, y de E4, 241 unidades, mientras que E2 dista 121 unidades de E4.</p></li>
<li>El coeficiente de la etapa 6 es 125, que se corresponde con la distancia entre E6 y E7, que son los “vecinos mas cercanos” de sus respectivos grupos.</li>
</ul>
</p>
<p></font></p>
</div>
</div>
</section>
<section id="método-del-vecino-más-lejano" class="slide level2">
<h2>Método del vecino más lejano</h2>
<div align="justify">
<font size="6">
<p>
<ul>
<li>El método del vecino mas lejano, al que también se refieren algunos textos como vinculación completa, complete linkage.</li>
<li>La distancia entre dos grupos se mide por la distancia entre sus miembros mas alejados.</li>
<li>Para realizar en R la metología del vecino más lejano se usaran los siguientes comandos para obtener el historial de aglomeración:</li>
</ul>
</p>
<p></font></p>
</div>
<pre><code>#efectuamos el cluster con método vecino más lejano
hclust.lejano&lt;-hclust(matriz.dis.euclid2,method=&quot;complete&quot;)
data.frame(hclust.lejano[2:1])</code></pre>
</section>
<section id="método-del-vecino-más-lejano-1" class="slide level2">
<h2>Método del vecino más lejano</h2>
<div id="left">
<p><img src="images/vecinolejano.JPG" width="100%" /></p>
<pre><code>##   height merge.1 merge.2
## 1     13      -3      -4
## 2     29      -7      -8
## 3     32      -1      -2
## 4     50      -5      -6
## 5    241       1       3
## 6    314       2       4
## 7   1649       5       6</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="5.9">
<p class="small">
Puede comprobarse ahora que el coeficiente de la etapa 5 es 241, que se corresponde con la distancia entre las empresas E1 y E4, o que en la etapa 7 el coeficiente es 1649, correspondiéndosecon la distancia entre las empresas 3 y 6.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="método-de-la-vinculación-promedio" class="slide level2">
<h2>Método de la vinculación promedio</h2>
<div align="justify">
<font size="6">
<p>
<ul>
<li><p>Conocido también como average linkage, la distancia entre dos grupos se obtiene calculando la <span style="color:blue">distancia promedio</span> entre <span style="color:blue">todos los pares de observaciones </span> que pueden formarse tomando un miembro de un grupo y otro miembro del otro grupo.</p></li>
<li>Para realizar en R la metología de la vinculación promedio se usaran los siguientes comandos para obtener el historial de aglomeración:</li>
</ul>
</p>
<p></font></p>
</div>
<pre><code>#efectuamos el cluster con método vinculación promedio
hclust.promedio&lt;-hclust(matriz.dis.euclid2,method=&quot;average&quot;)
data.frame(hclust.promedio[2:1])</code></pre>
</section>
<section id="método-de-la-vinculación-promedio-1" class="slide level2">
<h2>Método de la vinculación promedio</h2>
<div id="left">
<p><img src="images/vinculacion.JPG" width="100%" /></p>
<pre><code>##     height merge.1 merge.2
## 1   13.000      -3      -4
## 2   29.000      -7      -8
## 3   32.000      -1      -2
## 4   50.000      -5      -6
## 5  152.500       1       3
## 6  202.000       2       4
## 7 1323.625       5       6</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="5.9">
<p class="small">
<ul>
<li><p>Se observa como en la etapa 5 se fusiona el grupo formado por las empresas E1 y E2 (etiquetado como 3) con el formado por las empresas E3 y E4 (etiquetado como 1).</p></li>
<li>La imagen muestra como se obtiene la distancia de 152.5 usando todas las posibles combinaciones entre pares de puntos de los grupos E1-2 y E3-4 en las que hay un miembro de cada grupo.</li>
</ul>
</p>
<p></font></p>
</div>
</div>
</section>
<section id="método-de-ward" class="slide level2">
<h2>Método de Ward</h2>
<div align="justify">
<p><font size="6"> Se trata de un método general. La selección del par de clusters que se combinan en cada paso del agglomerative hierarchical clustering se basa en el valor óptimo de una función objetivo, pudiendo ser esta última cualquier función definida por el analista. El conocido método Ward’s minimum variance es un caso particular en el que el objetivo es <span style="color:blue">minimizar la suma total de la varianza intra-cluster</span>. En cada paso, se identifican aquellos 2 clusters cuya fusión conlleva <span style="color:blue">menor incremento de la varianza total intra-cluster</span>.</p>
<p></font></p>
</div>
</section>
<section id="método-de-ward-1" class="slide level2">
<h2>Método de Ward</h2>
<div id="left">
<pre><code>#efectuamos el cluster con método de Ward
hclust.ward&lt;-hclust(matriz.dis.euclid2,method=&quot;ward.D&quot;)
data.frame(hclust.ward[2:1])</code></pre>
<pre><code>##   height merge.1 merge.2
## 1   13.0      -3      -4
## 2   29.0      -7      -8
## 3   32.0      -1      -2
## 4   50.0      -5      -6
## 5  282.5       1       3
## 6  364.5       2       4
## 7 4909.0       5       6</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
<ul>
<li>Por ejemplo en el paso 6, la heterogeneidad total medida del modo descrito seria: 364.5 que es la menor de todas las posibles fusiones y por eso es la que el análisis de conglomerados elige, como se observa en el historial de conglomeración de ese mismo cuadro.</li>
</ul>
</p>
<p></font></p>
</div>
</div>
</section>
<section id="elección-entre-los-distintos-métodos-de-agrupación" class="slide level2">
<h2>Elección entre los distintos métodos de agrupación</h2>
<div align="justify">
<font size="6">
<p>
<ul>
<li>El método del <span style="color:blue">vecino más cercano</span> es más <span style="color:blue">sensible</span> a la presencia de <span style="color:blue">observaciones anómalas</span> (outliers) que el método del vecino más lejano.</li>
<li>El método del <span style="color:blue">vecino más lejano identifica</span> habitualmente <span style="color:blue">grupos muy homogéneos</span>, en los que las observaciones son muy parecidas unas a otras.</li>
<li>El <span style="color:blue">método de Ward</span> tiende a encontrar <span style="color:blue">conglomerados</span> no solo <span style="color:blue">muy compactos</span>, sino también de <span style="color:blue">tamaño similar</span>.</li>
<li>El método del <span style="color:blue">vecino más cercano</span> tiene tendencia a <span style="color:blue">crear menos grupos</span> que el del <span style="color:blue">vecino mas lejano</span>.</li>
</ul>
</p>
<p></font></p>
</div>
</section>
<section id="selección-del-número-de-conglomerados-de-la-solución" class="slide level2">
<h2>Selección del número de conglomerados de la solución</h2>
<div align="justify">
<p><font size="6"> Algunos autores han revisado e implementado en <code>R</code> un conjunto de índices que, si bien de manera individual pueden tener mayor o menor eficacia en la detección del número óptimo de conglomerados, tomados en su conjunto pueden ser de gran ayuda en la medida en que una mayoría de ellos apunten a una solución determinada. Nos centraremos en aquellos que son compartidos por más paquetes de <code>R</code>, en concreto el índice DB y el índice de Dunn, junto con dos índices con soporte grafico, el Índice de Hubert y el Dindex. </font></p>
</div>
</section>
<section id="índice-db" class="slide level2">
<h2>Índice DB</h2>
<div align="justify">
<p><font size="6"> Es una función del <span style="color:blue">ratio</span> entre la <span style="color:blue">dispersión interna de cada cluster</span> y la <span style="color:blue">separación entre ellos</span>. Se calcula mediante la expresión: <span class="math display">\[DB(q)=\frac{1}{q} \sum_{k=1}^{q} \operatorname*{máx}_{k \neq l} \left(\frac{\delta_k+\delta_l}{d_{kl}}\right)\]</span> donde <span class="math inline">\(k,l=1,\ldots,q\;\)</span> número del conglomerado,<br> <span class="math inline">\(d_{kl}=\sqrt[v]{\sum_{j=1}^{p} |c_{kj}-c_{lj}|^v}\)</span> es la distancia entre los centroides de los conglomerados <span class="math inline">\(C_k\)</span> y <span class="math inline">\(C_l\)</span> <br> <span class="math inline">\(\delta_k=\sqrt[u]{ \frac{1}{n_k} \sum_{i \in C_k} \sum_{j=1}^{p} |x_{ij}-c_{kj}|^u}\)</span> es la medida de la dispersión del cluster <span class="math inline">\(C_k\)</span> <br> Pues bien, el valor <span class="math inline">\(q\)</span> que minimiza <span class="math inline">\(DB(q)\)</span> se considera el número adecuado de conglomerados. </font></p>
</div>
</section>
<section id="índice-de-dunn" class="slide level2">
<h2>Índice de Dunn</h2>
<div align="justify">
<p><font size="5.9"> Define la ratio entre la <span style="color:blue">mínima distancia intraconglomerado</span> y la <span style="color:blue">máxima distancia interconglomerado</span>. Lo hace del siguiente modo: <span class="math display">\[\text{Dunn}= \operatorname*{mín}_{1 \leq i &lt; j \leq q } d\left(C_i,C_j\right) /  \operatorname*{máx \quad diam \left(C_k\right)}_{1 \leq k \leq q}
 \]</span> donde <span class="math inline">\(d\left(C_i,C_j\right)\)</span> es la <span style="color:blue">función de disimilaridad entre dos conglomerados</span> <span class="math inline">\(C_i\)</span> y <span class="math inline">\(C_j\)</span> definida como <span class="math display">\[d\left(C_i,C_j\right)=\operatorname*{mín}_{x \in C_i, y \in C_j } d\left(x,y\right)\]</span> es el <span style="color:blue">diámetro de un conglomerado</span> que puede considerarse como una <span style="color:blue">medida de dispersión</span>. Si los datos contienen <span style="color:blue">conglomerados compactos y bien separados</span>, el <span style="color:blue">diámetro</span> de los mismos debería ser <span style="color:blue">pequeño</span> y la <span style="color:blue">distancia</span> entre los conglomerados se espera que sea <span style="color:blue">grande</span>, de esta forma se <span style="color:blue">maximizaría</span> el <span style="color:blue">índice de Dunn</span>. </font></p>
</div>
</section>
<section id="estadístico-de-hubert" class="slide level2">
<h2>Estadístico de Hubert</h2>
<div align="justify">
<p><font size="5.9"> El estadístico <span class="math inline">\(\Gamma\)</span> de Hubert es el coeficiente de correlación serial entre dos matrices que, cuando son simétricas, puede escribirse del siguiente modo: <span class="math display">\[\Gamma(P,Q)=\frac{1}{N_t} \sum_{i=1}^{n-1} P_{ij}Q_{ij}, \quad i&lt;j\]</span> donde <span class="math inline">\(P\)</span> es la matriz de proximidad del conjunto de datos y <span class="math inline">\(Q\)</span> es una matriz <span class="math inline">\(n \times n\)</span> cuyo elemento <span class="math inline">\((i, j)\)</span> es igual a la distancia entre dos puntos representativos <span class="math inline">\((v_{ci}, v_{cj})\)</span> de los conglomerados a los que pertenecen <span class="math inline">\(x_i\)</span> y <span class="math inline">\(x_j\)</span>. <br> <span style="color:blue">Valores altos del estadístico <span class="math inline">\(\Gamma\)</span></span> normalizado indican la existencia de <span style="color:blue">conglomerados compactos</span>, por lo que en el gráfico en el que se relaciona <span class="math inline">\(\Gamma\)</span> y <span class="math inline">\(q\)</span> (número de conglomerados) buscaremos un punto de inflexión que se corresponda con un incremento significativo de <span class="math inline">\(\Gamma\)</span>. El número de conglomerado donde esto ocurra sera el óptimo. </font></p>
</div>
</section>
<section id="índice-dindex" class="slide level2">
<h2>Índice Dindex</h2>
<div align="justify">
<p><font size="5.9"> se basa en la <span style="color:blue">ganancia de inercia dentro del conglomerado</span>, que <span style="color:blue">mide el grado de homogeneidad de los datos asociados con ese grupo</span>. Calcula las distancias y las compara con un punto de referencia del perfil, normalmente el centroide. Se define: <span class="math display">\[w(P^q)=\frac{1}{q} \sum_{k=1}^{q} \frac{1}{n_k} \sum_{i \in C_k} d(x_i,c_k)\]</span> Dadas dos particiones <span class="math inline">\(P^{k-1}\)</span> formadas por <span class="math inline">\(k—1\)</span> conglomerados y <span class="math inline">\(P^k\)</span> particiones formadas por <span class="math inline">\(k\)</span> conglomerados, la ganancia de inercia intraconglomerado se define por: <span class="math display">\[Gain=w(P^{q-1})-w(P^q)\]</span> debiendo <span style="color:blue">minimizarse el valor de Gain</span>, lo que se identifica con un <span style="color:blue">recodo en el gráfico</span> que se corresponde con una <span style="color:blue">caída significativa de las primeras diferencias de Gain</span> cuando se representa frente al número de conglomerados a cuya identificación ayuda el equivalente crecimiento en las segundas diferencias que debe acompañarle. </font></p>
</div>
</section>
<section id="identificación-del-número-adecuado-de-conglomerados" class="slide level2">
<h2>Identificación del número adecuado de conglomerados</h2>
<div align="justify">
<font size="6">
<p>
<ul>
<li>Se genera una base de datos simulada de dos variables y 200 casos donde los conglomerados estén perfectamente separados, en la medida en que son datos aleatorios que siguen una normal dondelas medias de cada conglomerado son, respectivamente, 1, 3, 6 y 9 con distintas varianzas.</li>
<li>Se puede apreciar claramente que existen cuatro conglomerados muy definidos que el conjunto de índices es capaz de detectar, la confianza en la eficacia del sistema de índices para detectar el número adecuado de grupos en situaciones no evidentes se refuerza.</li>
</ul>
</p>
<p></font></p>
</div>
</section>
<section id="identificación-del-número-adecuado-de-conglomerados-1" class="slide level2">
<h2>Identificación del número adecuado de conglomerados</h2>
<div id="left">
<pre><code>set.seed(1)
x&lt;-rbind(matrix(rnorm(100,sd=0.1),ncol=2),
         matrix(rnorm(100,mean=1,sd=0.2),ncol=2),
         matrix(rnorm(100,mean=5,sd=0.1),ncol=2),
         matrix(rnorm(100,mean=7,sd=0.2),ncol=2))

DatosCaso3.2&lt;-data.frame(x)
#Gráfico
library(ggplot2)
ggplot(data=DatosCaso3.2, aes(X1,X2)) + geom_point()
</code></pre>
</div>
<div id="right">
<p><img src="Clase-6_files/figure-revealjs/unnamed-chunk-28-1.png" width="768" /></p>
</div>
</section>
<section id="identificación-del-número-adecuado-de-conglomerados-2" class="slide level2">
<h2>Identificación del número adecuado de conglomerados</h2>
<p>La sentencia que solicita el cálculo de los indicadores es la siguiente:</p>
<pre><code>#Pedimos los indicadores para un jerárquico con distancia euclídea y método de ward

library(NbClust)
res&lt;-NbClust(DatosCaso3.2, distance = &quot;euclidean&quot;, min.nc=2, max.nc=8, method = &quot;ward.D2&quot;, index = &quot;alllong&quot;)

res$All.index
res$Best.nc
res$Best.partition
</code></pre>
</section>
<section id="identificación-del-número-adecuado-de-conglomerados-3" class="slide level2">
<h2>Identificación del número adecuado de conglomerados</h2>
<p><img src="images/indice1.JPG" width="100%" /></p>
</section>
<section id="identificación-del-número-adecuado-de-conglomerados-4" class="slide level2">
<h2>Identificación del número adecuado de conglomerados</h2>
<p><img src="images/indice2.JPG" width="100%" /></p>
</section>
<section id="identificación-del-número-adecuado-de-conglomerados-5" class="slide level2">
<h2>Identificación del número adecuado de conglomerados</h2>
<div align="justify">
<font size="6">
<p>
<ul>
<li>La opción por defecto del paquete <code>NbClust</code> es lo que denomina <em>majority rule</em>, es decir elegir la solución que más indicadores recomiendan.</li>
<li>Analizar la <span style="color:blue">propuesta</span> que realizan aquellos <span style="color:blue">indicadores que mejor desempeño han demostrado</span> en los <span style="color:blue">ejercicios de simulación</span>. Los mejores cinco indicadores serian los indices: CH, Duda, Cindex, Gamma y Beale.</li>
</ul>
</p>
<p></font></p>
</div>
</section>
<section id="identificación-del-número-adecuado-de-conglomerados-6" class="slide level2">
<h2>Identificación del número adecuado de conglomerados</h2>
<div align="justify">
<font size="6">
<p>
<ul>
<li>Si analizamos los cinco indicadores que se supone que tienen un mejor desempeño, la propuesta de los mismos seria: CH (4), Duda (4), Cindex (6) y Beale (4), lo que parece corroborarla regla de la mayoría.</li>
<li>Aunque el apoyo de estos índices es tremendamente valioso y supone una gran mejora sobre la mera consulta del dendograma, el investigador no debe olvidar que la <span style="color:blue">mejor validación</span> de los conglomerados es que estos <span style="color:blue">tengan sentido</span> y <span style="color:blue">puedan interpretarse</span> en el contexto del problema de investigación.</li>
</ul>
</p>
<p></font></p>
</div>
</section>
<section id="elección-entre-análisis-de-conglomerados-jerárquico-y-no-jerárquico" class="slide level2">
<h2>Elección entre análisis de conglomerados jerárquico y no jerárquico</h2>
<div align="justify">
<font size="6">
<p>
<ul>
<li>Si el investigador tiene una <span style="color:blue">presunción razonable</span> de cuál puede ser el <span style="color:blue">número de grupos</span> naturales en que se agregan sus observaciones, el <span style="color:blue" análisis="" no="" jerárquico=""></span> seria una buena opción.</li>
<li>Los <span style="color:blue">métodos jerárquicos</span> <span style="color:red">no siempre</span> son de posible aplicación cuando los <span style="color:green">tamaños muestrales son muy altos y/o con numerosas variables</span> y eso independientemente del incremento en la potencia de los ordenadores.</li>
</ul>
</p>
<p></font></p>
</div>
</section>
    </div>
  </div>

  <script src="Clase-6_files/reveal.js-3.3.0.1/lib/js/head.min.js"></script>
  <script src="Clase-6_files/reveal.js-3.3.0.1/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,
        // Vertical centering of slides
        center: true,
        // Transition style
        transition: 'fade', // none/fade/slide/convex/concave/zoom
        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom



        // Optional reveal.js plugins
        dependencies: [
          { src: 'Clase-6_files/reveal.js-3.3.0.1/plugin/notes/notes.js', async: true },
          { src: 'Clase-6_files/reveal.js-3.3.0.1/plugin/zoom-js/zoom.js', async: true },
        ]
      });
    </script>
  <!-- dynamically load mathjax for compatibility with self-contained -->
  <script>
    (function () {
      var script = document.createElement("script");
      script.type = "text/javascript";
      script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
      document.getElementsByTagName("head")[0].appendChild(script);
    })();
  </script>

<script>
  (function() {
    if (window.jQuery) {
      Reveal.addEventListener( 'slidechanged', function(event) {  
        window.jQuery(event.previousSlide).trigger('hidden');
        window.jQuery(event.currentSlide).trigger('shown');
      });
    }
  })();
</script>


  </body>
</html>
