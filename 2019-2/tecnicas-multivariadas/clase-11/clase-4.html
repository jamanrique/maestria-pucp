<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Dra. Rocío Maehara" />
  <title>Escalamiento multidimensional</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="clase-4_files/reveal.js-3.3.0.1/css/reveal.css"/>



<link rel="stylesheet" href="clase-4_files/reveal.js-3.3.0.1/css/theme/white.css" id="theme">


  <!-- some tweaks to reveal css -->
  <style type="text/css">
    .reveal h1 { font-size: 2.0em; }
    .reveal h2 { font-size: 1.5em;  }
    .reveal h3 { font-size: 1.25em;	}
    .reveal h4 { font-size: 1em;	}

    .reveal .slides>section,
    .reveal .slides>section>section {
      padding: 0px 0px;
    }



    .reveal table {
      border-width: 1px;
      border-spacing: 2px;
      border-style: dotted;
      border-color: gray;
      border-collapse: collapse;
      font-size: 0.7em;
    }

    .reveal table th {
      border-width: 1px;
      padding-left: 10px;
      padding-right: 25px;
      font-weight: bold;
      border-style: dotted;
      border-color: gray;
    }

    .reveal table td {
      border-width: 1px;
      padding-left: 10px;
      padding-right: 25px;
      border-style: dotted;
      border-color: gray;
    }


  </style>

    <style type="text/css">code{white-space: pre;}</style>

    <link rel="stylesheet" href="logo.css"/>
    <link rel="stylesheet" href="style.css"/>

<!-- Printing and PDF exports -->
<script id="paper-css" type="application/dynamic-css">

/* Default Print Stylesheet Template
   by Rob Glazebrook of CSSnewbie.com
   Last Updated: June 4, 2008

   Feel free (nay, compelled) to edit, append, and
   manipulate this file as you see fit. */


@media print {

	/* SECTION 1: Set default width, margin, float, and
	   background. This prevents elements from extending
	   beyond the edge of the printed page, and prevents
	   unnecessary background images from printing */
	html {
		background: #fff;
		width: auto;
		height: auto;
		overflow: visible;
	}
	body {
		background: #fff;
		font-size: 20pt;
		width: auto;
		height: auto;
		border: 0;
		margin: 0 5%;
		padding: 0;
		overflow: visible;
		float: none !important;
	}

	/* SECTION 2: Remove any elements not needed in print.
	   This would include navigation, ads, sidebars, etc. */
	.nestedarrow,
	.controls,
	.fork-reveal,
	.share-reveal,
	.state-background,
	.reveal .progress,
	.reveal .backgrounds {
		display: none !important;
	}

	/* SECTION 3: Set body font face, size, and color.
	   Consider using a serif font for readability. */
	body, p, td, li, div {
		font-size: 20pt!important;
		font-family: Georgia, "Times New Roman", Times, serif !important;
		color: #000;
	}

	/* SECTION 4: Set heading font face, sizes, and color.
	   Differentiate your headings from your body text.
	   Perhaps use a large sans-serif for distinction. */
	h1,h2,h3,h4,h5,h6 {
		color: #000!important;
		height: auto;
		line-height: normal;
		font-family: Georgia, "Times New Roman", Times, serif !important;
		text-shadow: 0 0 0 #000 !important;
		text-align: left;
		letter-spacing: normal;
	}
	/* Need to reduce the size of the fonts for printing */
	h1 { font-size: 28pt !important;  }
	h2 { font-size: 24pt !important; }
	h3 { font-size: 22pt !important; }
	h4 { font-size: 22pt !important; font-variant: small-caps; }
	h5 { font-size: 21pt !important; }
	h6 { font-size: 20pt !important; font-style: italic; }

	/* SECTION 5: Make hyperlinks more usable.
	   Ensure links are underlined, and consider appending
	   the URL to the end of the link for usability. */
	a:link,
	a:visited {
		color: #000 !important;
		font-weight: bold;
		text-decoration: underline;
	}
	/*
	.reveal a:link:after,
	.reveal a:visited:after {
		content: " (" attr(href) ") ";
		color: #222 !important;
		font-size: 90%;
	}
	*/


	/* SECTION 6: more reveal.js specific additions by @skypanther */
	ul, ol, div, p {
		visibility: visible;
		position: static;
		width: auto;
		height: auto;
		display: block;
		overflow: visible;
		margin: 0;
		text-align: left !important;
	}
	.reveal pre,
	.reveal table {
		margin-left: 0;
		margin-right: 0;
	}
	.reveal pre code {
		padding: 20px;
		border: 1px solid #ddd;
	}
	.reveal blockquote {
		margin: 20px 0;
	}
	.reveal .slides {
		position: static !important;
		width: auto !important;
		height: auto !important;

		left: 0 !important;
		top: 0 !important;
		margin-left: 0 !important;
		margin-top: 0 !important;
		padding: 0 !important;
		zoom: 1 !important;

		overflow: visible !important;
		display: block !important;

		text-align: left !important;
		-webkit-perspective: none;
		   -moz-perspective: none;
		    -ms-perspective: none;
		        perspective: none;

		-webkit-perspective-origin: 50% 50%;
		   -moz-perspective-origin: 50% 50%;
		    -ms-perspective-origin: 50% 50%;
		        perspective-origin: 50% 50%;
	}
	.reveal .slides section {
		visibility: visible !important;
		position: static !important;
		width: auto !important;
		height: auto !important;
		display: block !important;
		overflow: visible !important;

		left: 0 !important;
		top: 0 !important;
		margin-left: 0 !important;
		margin-top: 0 !important;
		padding: 60px 20px !important;
		z-index: auto !important;

		opacity: 1 !important;

		page-break-after: always !important;

		-webkit-transform-style: flat !important;
		   -moz-transform-style: flat !important;
		    -ms-transform-style: flat !important;
		        transform-style: flat !important;

		-webkit-transform: none !important;
		   -moz-transform: none !important;
		    -ms-transform: none !important;
		        transform: none !important;

		-webkit-transition: none !important;
		   -moz-transition: none !important;
		    -ms-transition: none !important;
		        transition: none !important;
	}
	.reveal .slides section.stack {
		padding: 0 !important;
	}
	.reveal section:last-of-type {
		page-break-after: avoid !important;
	}
	.reveal section .fragment {
		opacity: 1 !important;
		visibility: visible !important;

		-webkit-transform: none !important;
		   -moz-transform: none !important;
		    -ms-transform: none !important;
		        transform: none !important;
	}
	.reveal section img {
		display: block;
		margin: 15px 0px;
		background: rgba(255,255,255,1);
		border: 1px solid #666;
		box-shadow: none;
	}

	.reveal section small {
		font-size: 0.8em;
	}

}  
</script>


<script id="pdf-css" type="application/dynamic-css">
    
/**
 * This stylesheet is used to print reveal.js
 * presentations to PDF.
 *
 * https://github.com/hakimel/reveal.js#pdf-export
 */

* {
	-webkit-print-color-adjust: exact;
}

body {
	margin: 0 auto !important;
	border: 0;
	padding: 0;
	float: none !important;
	overflow: visible;
}

html {
	width: 100%;
	height: 100%;
	overflow: visible;
}

/* Remove any elements not needed in print. */
.nestedarrow,
.reveal .controls,
.reveal .progress,
.reveal .playback,
.reveal.overview,
.fork-reveal,
.share-reveal,
.state-background {
	display: none !important;
}

h1, h2, h3, h4, h5, h6 {
	text-shadow: 0 0 0 #000 !important;
}

.reveal pre code {
	overflow: hidden !important;
	font-family: Courier, 'Courier New', monospace !important;
}

ul, ol, div, p {
	visibility: visible;
	position: static;
	width: auto;
	height: auto;
	display: block;
	overflow: visible;
	margin: auto;
}
.reveal {
	width: auto !important;
	height: auto !important;
	overflow: hidden !important;
}
.reveal .slides {
	position: static;
	width: 100%;
	height: auto;

	left: auto;
	top: auto;
	margin: 0 !important;
	padding: 0 !important;

	overflow: visible;
	display: block;

	-webkit-perspective: none;
	   -moz-perspective: none;
	    -ms-perspective: none;
	        perspective: none;

	-webkit-perspective-origin: 50% 50%; /* there isn't a none/auto value but 50-50 is the default */
	   -moz-perspective-origin: 50% 50%;
	    -ms-perspective-origin: 50% 50%;
	        perspective-origin: 50% 50%;
}

.reveal .slides section {
	page-break-after: always !important;

	visibility: visible !important;
	position: relative !important;
	display: block !important;
	position: relative !important;

	margin: 0 !important;
	padding: 0 !important;
	box-sizing: border-box !important;
	min-height: 1px;

	opacity: 1 !important;

	-webkit-transform-style: flat !important;
	   -moz-transform-style: flat !important;
	    -ms-transform-style: flat !important;
	        transform-style: flat !important;

	-webkit-transform: none !important;
	   -moz-transform: none !important;
	    -ms-transform: none !important;
	        transform: none !important;
}

.reveal section.stack {
	margin: 0 !important;
	padding: 0 !important;
	page-break-after: avoid !important;
	height: auto !important;
	min-height: auto !important;
}

.reveal img {
	box-shadow: none;
}

.reveal .roll {
	overflow: visible;
	line-height: 1em;
}

/* Slide backgrounds are placed inside of their slide when exporting to PDF */
.reveal section .slide-background {
	display: block !important;
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	z-index: -1;
}

/* All elements should be above the slide-background */
.reveal section>* {
	position: relative;
	z-index: 1;
}

/* Display slide speaker notes when 'showNotes' is enabled */
.reveal .speaker-notes-pdf {
	display: block;
	width: 100%;
	max-height: none;
	left: auto;
	top: auto;
	z-index: 100;
}

/* Display slide numbers when 'slideNumber' is enabled */
.reveal .slide-number-pdf {
	display: block;
	position: absolute;
	font-size: 14px;
}

</script>


<script>
var style = document.createElement( 'style' );
style.type = 'text/css';
var style_script_id = window.location.search.match( /print-pdf/gi ) ? 'pdf-css' : 'paper-css';
var style_script = document.getElementById(style_script_id).text;
style.innerHTML = style_script;
document.getElementsByTagName('head')[0].appendChild(style);
</script>

</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title"><strong>Escalamiento multidimensional</strong></h1>
    <h2 class="author">Dra. Rocío Maehara</h2>
    <h3 class="date">16 de noviembre de 2019 <br> <img id='logopucp' src='logoPUCP.jpg'></h3>
</section>

<section id="introducción" class="slide level2">
<h2>Introducción</h2>
<div align="justify">
<p>El análisis de escalamiento multidimensional (MDS) es una <span style="color:blue"> técnica de reducción de datos </span> como otras que hemos visto anteriormente: análisis factorial o análisis de componentes principales, por ejemplo. El <span style="color:red"> objetivo principal </span> del MDS es <span style="color:blue">representar <span class="math inline">\(N\)</span> objetos en un espacio dimensional reducido (<span class="math inline">\(q\)</span> dimensiones, siendo <span class="math inline">\(q &lt; N\)</span>) </span>, de tal forma que la <span style="color:green"> distorsión causada por la reducción de la dimensionalidad sea la menor posible </span>, es decir, que las distancias entre los objetos representados en el espacio <span class="math inline">\(q\)</span> dimensional sean lo más parecidas posible a las distancias en el espacio <span class="math inline">\(N\)</span> dimensional.</p>
</div>
</section>
<section id="introducción-1" class="slide level2">
<h2>Introducción</h2>
<div align="justify">
<p>Dado que será <span style="color:blue"> difícil que las distancias coincidan</span>, el objetivo del MDS es <span style="color:green">conseguir que ambas configuraciones dimensionales sean lo más parecidas posible</span>, Para ello será necesario construir un <span style="color:brown">indicador de esa proximidad </span> que, como se detallará más adelante, denominaremos <span style="color:brown">stress o sstress</span>.</p>
</div>
</section>
<section id="valoración-de-la-imagen-de-superficies-comerciales" class="slide level2">
<h2>Valoración de la imagen de superficies comerciales</h2>
<div id="left">
<pre><code>datos &lt;- matrix(c(
0.0, 1.0, 2.1, 6.1, 5.2,
1.0, 0.0, 2.4, 6.9, 5.3,
2.1, 2.4, 0.0, 5.1, 4.1,
6.1, 6.9, 5.1, 0.0, 3.1,
5.2, 5.3, 4.1, 3.1,0.0), ncol=5, nrow=5, byrow=T,
dimnames=list(c(&quot;X1&quot;,&quot;X2&quot;,&quot;X3&quot;,&quot;X4&quot;,&quot;X5&quot;)))
datos</code></pre>
<pre><code>##    [,1] [,2] [,3] [,4] [,5]
## X1  0.0  1.0  2.1  6.1  5.2
## X2  1.0  0.0  2.4  6.9  5.3
## X3  2.1  2.4  0.0  5.1  4.1
## X4  6.1  6.9  5.1  0.0  3.1
## X5  5.2  5.3  4.1  3.1  0.0</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
Supongamos que hemos pedido a <span style="color:blue">100 consumidores</span> que valoren la <span style="color:blue">imagen que tienen de 5 superficies comerciales</span>, atendiendo a la similitud con que las perciben. Para ello se utiliza una <span style="color:green">escala de 0 (idénticas) a 7 (totalmente diferentes)</span>. <br> La siguiente <span style="color:brown">matriz de disparidades originales o proximidades</span> nos muestra las <span style="color:brown">medias de las puntuaciones</span> ofrecidas por los 100 consumidores. <br>
</p>
<p></font></p>
</div>
</div>
</section>
<section id="valoración-de-la-imagen-de-superficies-comerciales-1" class="slide level2">
<h2>Valoración de la imagen de superficies comerciales</h2>
<div id="left">
<pre><code>datos &lt;- matrix(c(
0.0, 1.0, 2.1, 6.1, 5.2,
1.0, 0.0, 2.4, 6.9, 5.3,
2.1, 2.4, 0.0, 5.1, 4.1,
6.1, 6.9, 5.1, 0.0, 3.1,
5.2, 5.3, 4.1, 3.1,0.0), ncol=5, nrow=5, byrow=T,
dimnames=list(c(&quot;X1&quot;,&quot;X2&quot;,&quot;X3&quot;,&quot;X4&quot;,&quot;X5&quot;)))
datos</code></pre>
<pre><code>##    [,1] [,2] [,3] [,4] [,5]
## X1  0.0  1.0  2.1  6.1  5.2
## X2  1.0  0.0  2.4  6.9  5.3
## X3  2.1  2.4  0.0  5.1  4.1
## X4  6.1  6.9  5.1  0.0  3.1
## X5  5.2  5.3  4.1  3.1  0.0</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
Si creamos un <span style="color:blue">mapa en dos dimensiones</span> para ilustrar mejor la percepción de los consumidores, este mapa debería representar como <span style="color:green">puntos cercanos a las superficies <span class="math inline">\(X_1\)</span> y <span class="math inline">\(X_2\)</span></span> porque la <span style="color:green">disparidad</span> entre ellas es<span style="color:green"> pequeña (1.0)</span>, tal y como refleja la matriz. Asimismo, las <span style="color:brown">superficies <span class="math inline">\(X_2\)</span> y <span class="math inline">\(X_4\)</span></span> deberían aparecer representadas muy <span style="color:brown">distantes</span> una de la otra, por cuanto su <span style="color:brown">disparidad</span> en la matriz es <span style="color:brown">elevada (6.9)</span>.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="valoración-de-la-imagen-de-superficies-comerciales-2" class="slide level2">
<h2>Valoración de la imagen de superficies comerciales</h2>
<div id="left">
<p><img src="clase-4_files/figure-revealjs/unnamed-chunk-3-1.png" width="768" /></p>
</div>
<div id="right">
<pre><code>library(smacof)
fit2 &lt;- mds(delta=datos,ndim=2, type=&quot;interval&quot;)
plot(fit2, main = &quot;Datos de la imagen de cadenas de electrodomésticos&quot;)</code></pre>
<div align="justify">
<font size="5.8">
<p class="small">
Se puede apreciar el <span style="color:blue">mapa</span> que se obtiene al <span style="color:blue">representar las coordenadas bidimensionales</span> resultantes de aplicar a la matriz anterior uno de los algoritmos que existen para efectuar un MDS, el implementado en <code>mds(smacof)</code>. Puede comprobarse como se constata la <span style="color:green">cercanía de <span class="math inline">\(X_1\)</span> y <span class="math inline">\(X_2\)</span></span> y la <span style="color:brown">lejanía de <span class="math inline">\(X_2\)</span> y <span class="math inline">\(X_4\)</span></span> que esperábamos.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="desarrollo-formal-de-la-técnica-msd" class="slide level2">
<h2>Desarrollo formal de la técnica MSD</h2>
<div align="justify">
<font size="6">
<p class="small">
Con el ejemplo de las superficies comerciales expuesto con anterioridad. Si <span style="color:blue">partimos de <span class="math inline">\(N\)</span> objetos (superficies comerciales)</span>, tendremos entonces <span style="color:blue"><span class="math inline">\(M=N(N—1)/2\)</span> disparidades originales</span> entre pares de objetos (10 en nuestro ejemplo). Asumiendo que no haya empates (los distintos algoritmos resuelven los empates de distintos modos), las <span style="color:green">disparidades</span> pueden escribirse en un <span style="color:green">orden estrictamente ascendente</span>: <span class="math display">\[s_{i_1k_1}&lt;s_{i_2k_2}&lt;\ldots&lt;s_{i_Mk_M}\]</span> donde <span style="color:brown"><span class="math inline">\(s_{i_1k_1}\)</span></span> es la <span style="color:brown">menor de las disparidades</span>. El subíndice <span class="math inline">\(i_1k_1\)</span> indica el <span style="color:brown">par de objetos</span> que son <span style="color:brown">más parecidos</span>.
</p>
<p></font></p>
</div>
</section>
<section id="el-algoritmo-básico-del-mds" class="slide level2">
<h2>El algoritmo básico del MDS</h2>
<div align="justify">
<font size="6">
<p class="small">
En nuestro ejemplo esta ordenación sería la siguiente: <span class="math display">\[1.0&lt; 2.1&lt; 2.4&lt; 3.1&lt; 4.1&lt; 5.1&lt; 5.2&lt; 5.3&lt; 6.1&lt; 6.9\]</span> <span class="math display">\[s_{12}&lt;s_{13}&lt;s_{23}&lt;s_{45}&lt;s_{35}&lt;s_{34}&lt;s_{15}&lt;s_{25}&lt;s_{14}&lt;s_{24}\]</span>
</p>
<p class="small">
Nuestro <span style="color:blue">objetivo</span> es encontrar una <span style="color:blue">nueva configuración <span class="math inline">\(q\)</span> dimensional</span> de los <span class="math inline">\(N\)</span> objetos (2 dimensiones y 5 objetos en el ejemplo), de tal forma que las <span style="color:brown">distancias calculadas entre ellos en ese espacio <span class="math inline">\(q\)</span> dimensional mantengan la ordenación anterior</span>. En el caso ideal de que se <span style="color:green">mantuviera el orden y las proporciones entre disparidades y distancias</span>, el <span style="color:green">gráfico de dispersión</span> entre ambas se representaría mediante una <span style="color:green">línea recta</span>.
</p>
<p></font></p>
</div>
</section>
<section id="el-algoritmo-básico-del-mds-1" class="slide level2">
<h2>El algoritmo básico del MDS</h2>
<div id="left">
<pre><code># Solución bidimensional
fit2$conf</code></pre>
<pre><code>##            D1          D2
## X1 -0.5504010  0.01970998
## X2 -0.6430815 -0.04506942
## X3 -0.2233691  0.14315764
## X4  0.8854840  0.20160756
## X5  0.5313676 -0.31940576</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
En el MDS se van <span style="color:blue">ensayando distintas configuraciones <span class="math inline">\(q\)</span> dimensionales</span> hasta que las <span style="color:blue">distancias en ese espacio y las disparidades originales guarden una relación lo más próxima posible a esta recta ideal</span>. <br> El código muestra la <span style="color:green">solución bidimensional final</span> resultante de la aplicación del MDS a los datos de nuestro ejemplo. En este cuadro aparecen las <span style="color:green">coordenadas de cada objeto (superficie comercial) en ese espacio bidimensional</span>.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="el-algoritmo-básico-del-mds-2" class="slide level2">
<h2>El algoritmo básico del MDS</h2>
<div id="left">
<pre><code>#Distancias entre las configuraciones
print(fit2$confdist)</code></pre>
<pre><code>##           X1        X2        X3        X4
## X2 0.1130754                              
## X3 0.3495557 0.4599869                    
## X4 1.4473605 1.5483417 1.1103925          
## X5 1.1336767 1.2060644 0.8852075 0.6299629</code></pre>
<pre><code>##            D1          D2
## X1 -0.5504010  0.01970998
## X2 -0.6430815 -0.04506942
## X3 -0.2233691  0.14315764
## X4  0.8854840  0.20160756
## X5  0.5313676 -0.31940576</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
A partir de esas <span style="color:blue">coordenadas</span> es sencillo derivar la <span style="color:blue">matriz de distancia entre los distintos objetos</span>. Así, tomando <span style="color:green">distancias euclídeas</span>, la distancia entre, por ejemplo, X1 y X2 tomaría el valor: <font size="3.5"> <span class="math display">\[d(X_1,X_2)=\sqrt{(-0.5504-(-0.6431))^2+(0.0197-(-0.0451))^2}=0.1131\]</span> </font> Repitiendo los cálculos para todos los objetos (estímulos), obtendríamos la <span style="color:brown">matriz de distancias <span class="math inline">\(\textbf{D}\)</span> entre las configuraciones</span> mostrada en el código.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="el-algoritmo-básico-del-mds-3" class="slide level2">
<h2>El algoritmo básico del MDS</h2>
<div id="left">
<pre><code># Matriz de disparidades
print(fit2$dhat)</code></pre>
<pre><code>##           X1        X2        X3        X4
## X2 0.1001109                              
## X3 0.3773818 0.4530011                    
## X4 1.3856397 1.5872913 1.1335752          
## X5 1.1587817 1.1839881 0.8815108 0.6294463</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
En el algoritmo del MDS se obtiene, como hemos señalado, una <span style="color:blue">transformación monótona de la matriz de distancias originales en el espacio <span class="math inline">\(N\)</span> dimensional</span> y es respecto a esa <span style="color:blue">transformación (matriz de disparidades <span class="math inline">\(\Delta\)</span>)</span> obtenida en <span style="color:green">cada iteración</span> con la que <span style="color:green">se va comparando la matriz <span class="math inline">\(\textbf{D}\)</span></span>.<br> El código muestra la <span style="color:brown">solución final bidimensional</span> alcanzada en la <span style="color:brown">última iteración proporciona la matriz de disparidades <span class="math inline">\(\Delta\)</span></span>.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="el-algoritmo-básico-del-mds-4" class="slide level2">
<h2>El algoritmo básico del MDS</h2>
<div id="left">
<p><img src="clase-4_files/figure-revealjs/unnamed-chunk-8-1.png" width="768" /></p>
</div>
<div id="right">
<pre><code>plot(fit2,plot.type=&quot;Shepard&quot;,plot.dim=c(1,2),sphere=TRUE,bubscale=0.1,col=1,
label.conf=list(label=TRUE,pos=3,col=1,cex=0.8),
shepard.x=NULL,identify=FALSE,
type=&quot;p&quot;,pch=20,asp=1,col.hist=NULL)</code></pre>
<div align="justify">
<font size="5">
<p class="small">
Así pues, la <span style="color:blue">matriz de disparidades <span class="math inline">\(\Delta\)</span></span> es simplemente una <span style="color:blue">transformación monótona de la matriz de distancias originales <span class="math inline">\(\textbf{S}\)</span></span>. Esto se puede comprobar representando, simplemente, en un <span style="color:green">gráfico de dispersión las distancias que aparecen en ambas</span>. Este gráfico es conocido como <span style="color:brown">diagrama de Shepard</span>, donde los <span style="color:brown">puntos sobre la diagonal</span> muestran la <span style="color:brown">transformación monótona</span> y los <span style="color:brown">puntos grises</span> muestran las <span style="color:brown">discrepancias que se producen</span>, que serán un <span style="color:brown">indicador de la bondad del ajuste</span> del modelo que veremos posteriormente.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="el-algoritmo-básico-del-mds-5" class="slide level2">
<h2>El algoritmo básico del MDS</h2>
<div align="justify">
<font size="6">
<p class="small">
El algoritmo usado en la técnica MDS ensaya distintas configuraciones bidimensionales hasta dar con aquella que <span style="color:blue">reduce en mayor grado las diferencias entre las matrices de distancias <span class="math inline">\(\textbf{D}\)</span> y disparidades <span class="math inline">\(\Delta\)</span></span>. Para ello necesitamos una función objetivo que se minimizará en cada iteración. Kruskal (1964a) propuso la siguiente función, que denominó stress: <span class="math display">\[Stress=\sqrt{\frac{\sum_{i \neq j} (d_{ij}-\delta_{ij})^2}{\sum_{i \neq j} d^2_{ij}}}\]</span> donde <span style="color:green"><span class="math inline">\(d_{ij}\)</span></span> son los <span style="color:green">elementos de la matriz de distancias</span> resultante de la solución <span class="math inline">\(q\)</span> dimensional en la interación que se esté realizando y <span style="color:green"><span class="math inline">\(\delta_{ij}\)</span></span> son los <span style="color:green">elementos de la matriz de disparidades</span> que, recordemos, no son sino una transformación monótona de los elementos de la matriz de disparidades originales entre los distintos objetos (estímulos).
</p>
<p></font></p>
</div>
</section>
<section id="el-algoritmo-básico-del-mds-6" class="slide level2">
<h2>El algoritmo básico del MDS</h2>
<div id="left">
<p><img src="images/stress.JPG" width="100%" /></p>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
En síntesis, el <span style="color:blue">stress</span> no es sino un <span style="color:blue">indicador</span> de <span style="color:blue">cuánto difieren en promedio</span> la <span style="color:blue">matriz con las distancias de la solución dimensional reducida</span> respecto a la <span style="color:blue">matriz con las disparidades originales</span>. El cuadrado del numerador pretende, únicamente, que no se compensen diferencias positivas con negativas. <br> El valor del <span style="color:green">stress</span> deberá ser <span style="color:green">tan pequeño como sea posible</span> y, en todo caso, reducirse en cada iteración. De no ser así, el algoritmo se detendrá.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="el-algoritmo-básico-del-mds-7" class="slide level2">
<h2>El algoritmo básico del MDS</h2>
<div align="justify">
<font size="6">
<p class="small">
Una <span style="color:blue">segunda medida</span> de las <span style="color:blue">discrepancias entre las matrices de disparidades y distancias</span> y, por ello, de calidad de la representación lograda por el MDS, es el estadístico denominado s-stress que fue propuesto por Takane et al. (1977) autores del algoritmo ALSCAL y que, por ello, es la función que se minimiza en ese algoritmo: <span class="math display">\[S-stress=\sqrt{\frac{\sum_{i \neq j} (d_{ij}-\delta_{ij})^2}{\sum_{i \neq j} d^4_{ij}}}\]</span> El valor del <span style="color:green">s-stress</span> está siempre <span style="color:green">comprendido entre 0 y 1</span> y cualquier <span style="color:green">valor inferior a 0.1</span> indica que la <span style="color:green">solución obtenida</span> es una <span style="color:green">buena representación</span> de los objetos de la solución <span class="math inline">\(N\)</span> dimensional inicial.
</p>
<p></font></p>
</div>
</section>
<section id="el-algoritmo-básico-del-mds-8" class="slide level2">
<h2>El algoritmo básico del MDS</h2>
<div id="left">
<p><img src="images/estimulos.JPG" width="100%" /></p>
</div>
<div id="right">
<div align="left">
<p><font size="6"> Matriz de disparidades <span class="math inline">\(\Delta\)</span></p>
<pre><code>print(fit2$dhat)</code></pre>
<pre><code>##           X1        X2        X3        X4
## X2 0.1001109                              
## X3 0.3773818 0.4530011                    
## X4 1.3856397 1.5872913 1.1335752          
## X5 1.1587817 1.1839881 0.8815108 0.6294463</code></pre>
<p>Distancias entre configuraciones <span class="math inline">\(\textbf{D}\)</span></p>
<pre><code>print(fit2$confdist)</code></pre>
<pre><code>##           X1        X2        X3        X4
## X2 0.1130754                              
## X3 0.3495557 0.4599869                    
## X4 1.4473605 1.5483417 1.1103925          
## X5 1.1336767 1.2060644 0.8852075 0.6299629</code></pre>
<p></font></p>
</div>
</div>
</section>
<section id="el-algoritmo-básico-del-mds-9" class="slide level2">
<h2>El algoritmo básico del MDS</h2>
<div id="left">
<p>Stress</p>
<pre><code>print(fit2$stress)</code></pre>
<pre><code>## [1] 0.02826073</code></pre>
<p>Stress por punto</p>
<pre><code>print(fit2$spp)</code></pre>
<pre><code>##        X1        X2        X3        X4        X5 
## 33.694099 13.906328  8.603052 36.712519  7.084002</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="5">
<p class="small">
La salida de smacof proporciona el valor final del stress. <br> Dado que este paquete no optimiza no calcula el s-stress. <br> Se comprueba que el stress 0.0282 obtenido alcanza el valor de “excelente”.<br> El paquete smacof permite también analizar la contribución de cada punto representado al stress, es decir, del total del desajuste, qué parte es debida a una mala representación de un punto determinado. En el caso del ejemplo, vemos que el punto peor representado sería el <span class="math inline">\(X_4\)</span> que supone el 36,7% del total del stress.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="el-algoritmo-básico-del-mds-10" class="slide level2">
<h2>El algoritmo básico del MDS</h2>
<div id="left">
<pre><code>plot(fit2, plot.type = &quot;bubbleplot&quot;)</code></pre>
<p><img src="clase-4_files/figure-revealjs/unnamed-chunk-13-1.png" width="768" /></p>
</div>
<div id="right">
<div align="justify">
<pre><code>plot(fit2, plot.type = &quot;stressplot&quot;)</code></pre>
<p><img src="clase-4_files/figure-revealjs/unnamed-chunk-14-1.png" width="768" /></p>
</div>
</section>
<section id="el-algoritmo-básico-del-mds-11" class="slide level2">
<h2>El algoritmo básico del MDS</h2>
<div id="left">
<pre><code>print(1-fit2$rss)</code></pre>
<pre><code>## [1] 0.9920133</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="5">
<p class="small">
Como ya se indicó, la solución dimensional reducida es una buena representación de la solución <span class="math inline">\(N\)</span> dimensional si la ordenación de las distancias entre los objetos de la primera mantiene la ordenación de las disparidades originales de la segunda. En el caso ideal, el gráfico de dispersión que representara distancias y disparidades debería ser una línea recta. <br>
</p>
<p></font></p>
</div>
</div>
</section>
<section id="el-algoritmo-básico-del-mds-12" class="slide level2">
<h2>El algoritmo básico del MDS</h2>
<div id="left">
<p><img src="clase-4_files/figure-revealjs/unnamed-chunk-16-1.png" width="768" /></p>
</div>
<div id="right">
<div align="justify">
<font size="5">
<p class="small">
<p>Del análisis del diagrama de Shepard se desprende que la ordenación lograda con las distancias coincide de manera prácticamente perfecta con las disparidades. <br> Ahora cabe preguntarse ¿en qué medida se aleja la relación que se ha representado de la relación ideal? Si efectuáramos una regresión simple tomando las disparidades como variables independientes y las distancias como dependientes, el coeficiente de determinación de esta regresión sería un buen indicador de lo cercano al ideal de la solución obtenida. Pues bien, ese coeficiente de determinación es el indicador RSQ que como vimos tiene un valor cercano a la unidad (0.9920).</p>
</p>
<p></font></p>
</div>
</div>
</section>
<section id="recogida-de-datos-para-un-escalamiento" class="slide level2">
<h2>Recogida de datos para un escalamiento</h2>
<div align="justify">
<p class="small">
<font size="6"> El input básico del MDS es, como ya hemos señalado, la similaridad entre cada par de los <span class="math inline">\(N\)</span> objetos que se están analizando. A esta medida, se la suele denominar también proximidad, tal como se ha apuntado. Estas medidas pueden obtenerse de muy diversas formas. Las dos más habituales son: <br> - Pedir a los individuos que emitan un juicio de similaridad entre cada par de estímulos. <br> - Que puntúen en qué grado un atributo determinado está presente en el estímulo. <br> Al primer tipo de medidas se las conoce como similaridades directas y al segundo como similaridades derivadas. </font>
</p>
</div>
</section>
<section id="tipos-de-escalamiento-multidimensional" class="slide level2">
<h2>Tipos de escalamiento multidimensional</h2>
<div align="justify">
<p class="small">
<p><font size="6"> El escalamientos multidimensional no es una técnica, sino un conjunto de ellas. Los elementos que permiten diferenciarlas son:</p>
<ul>
<li>El número de matrices de proximidades.</li>
<li>La forma de las mismas (cuadradas o rectangulares).</li>
<li>Si el algoritmo contempla o no ponderaciones. </font></li>
</ul>
</p>
</div>
</section>
<section id="escalamiento-multidimensional-clásico" class="slide level2">
<h2>Escalamiento multidimensional clásico</h2>
<div align="justify">
<p class="small">
<p><font size="6"> Esta formado por una única matriz de proximidades y esta es cuadrada. Existen dos tipos de esclamiento multidimensional clásico en función de cómo sean las medidas de similaridad.</p>
<ul>
<li><p>Métrico: Asume que la medidas de similaridad son de intervalo o de razón. Este seria el caso, por ejemplo, de una matriz donde los estímulos son ciudades, y la medida de proximidad, la distancia en kilémetros.</p></li>
<li>No métrico: Donde el nivel de medida de la variables es ordinal. </font></li>
</ul>
</p>
</div>
</section>
<section id="escalamiento-multidimensional-clásico-1" class="slide level2">
<h2>Escalamiento multidimensional clásico</h2>
<div align="justify">
<p class="small">
<font size="6"> En la función <code>mds{smacof}</code> que es la que estima este tipo de escalamiento, la opción por uno u otro instrumento de medida se elige con el modificador <br> <code>type=c(&quot;ratio&quot;,&quot;interval&quot;,&quot;ordinal&quot;,&quot;mspline&quot;)</code>. </font>
</p>
</div>
</section>
<section id="desarrollo-educativo-de-distintas-zonas-del-mundo" class="slide level2">
<h2>Desarrollo educativo de distintas zonas del mundo</h2>
<div id="left">
<p><img src="images/cuadro.JPG" width="100%" /></p>
</div>
<div id="right">
<div align="justify">
<font size="5">
<p class="small">
Supongamos que un investigador en economía de la educación desea saber cuál es la posición relativa de distintas zonas del mundo respecto al nivel de desarrollo educativo.<br> En la tabla se recogen los principales indicadores que este investigador maneja para esta finalidad. Es obvio que podría recurrirse a un análisis de conglomerados para conseguir un número de grupos territoriales homogéneos, pero estos grupos estarán próximos o alejados entre sí. Estas distancias, para el investigador, son relevantes porque le muestran las diferencias regionales y el camino que queda por recorrer.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="desarrollo-educativo-de-distintas-zonas-del-mundo-1" class="slide level2">
<h2>Desarrollo educativo de distintas zonas del mundo</h2>
<div id="left">
<p><img src="images/cuadro.JPG" width="100%" /></p>
</div>
<div id="right">
<p><img src="images/indi.JPG" width="100%" /></p>
</div>
</section>
<section id="desarrollo-educativo-de-distintas-zonas-del-mundo-2" class="slide level2">
<h2>Desarrollo educativo de distintas zonas del mundo</h2>
<div id="left">
<p><img src="images/cuadro.JPG" width="100%" /></p>
</div>
<div id="right">
<p><img src="images/geogra.JPG" width="100%" /></p>
</div>
</section>
<section id="desarrollo-educativo-de-distintas-zonas-del-mundo-3" class="slide level2">
<h2>Desarrollo educativo de distintas zonas del mundo</h2>
<div id="left">
<p><img src="images/cuadro.JPG" width="100%" /></p>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
• Países menos adelantados. Se consideran, de todos los anteriores, aquellos países con un atraso mayor. Este punto servirá en el MDS de referencia de nivel. Incluye Afganistán, Angola, Bangladés, Benín, Bután, Etiopía, Gambia, Guinea, Haití, Nepal, Níger, Congo, Tanzania, Yemen, Zambia, entre otros.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="desarrollo-educativo-de-distintas-zonas-del-mundo-4" class="slide level2">
<h2>Desarrollo educativo de distintas zonas del mundo</h2>
<div id="left">
<pre><code>datos &lt;- read.table(&quot;educa.txt&quot;, header=F)
rownames(datos)&lt;- c(&quot;Z1&quot;, &quot;Z2&quot;, &quot;Z3&quot;,&quot;Z4&quot;, &quot;Z5&quot;, &quot;Z6&quot;, &quot;Z7&quot;, &quot;Z8&quot;, &quot;Z9&quot;, &quot;Z10&quot;,&quot;Z11&quot;,&quot;Z12&quot;)
colnames(datos) &lt;- c(&quot;I1&quot;,&quot;I2&quot;,&quot;I3&quot;,&quot;I4&quot;,&quot;I5&quot;,&quot;I6&quot;,&quot;I7&quot;)
# Normalizamos los indicadores
datos_norm &lt;- scale(datos)
# Calculamos la matriz de distancias
datosf &lt;-  dist(datos_norm,method = &quot;euclidian&quot;,diag=T,upper=T)
m &lt;- as.matrix(datosf)
datos &lt;- as.dist(m)
</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="5">
<p class="small">
Como puede comprobarse, los datos de la tabla anterior no son una medida de proximidad entre los estímulos (las 12 zonas). Para obtener esta matriz calcularíamos las distancias euclídeas entre los estímulos teniendo en cuenta las variables que los caracterizan (I1 a I7). Lógicamente las variables son previamente estandarizadas, como se observa en la sintaxis.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="desarrollo-educativo-de-distintas-zonas-del-mundo-5" class="slide level2">
<h2>Desarrollo educativo de distintas zonas del mundo</h2>
<div id="left">
<pre><code>## 
## Call:
## mds(delta = datos, ndim = 2, type = &quot;ratio&quot;)
## 
## Model: Symmetric SMACOF 
## Number of objects: 12 
## Stress-1 value: 0.071 
## Number of iterations: 64</code></pre>
<pre><code>## [1] 0.07110678</code></pre>
</div>
<div id="right">
<pre><code>library(smacof)
fit &lt;- mds(delta=datos,ndim=2,type=&quot;ratio&quot;)
fit
# Stress
print(fit$stress)
</code></pre>
<div align="justify">
<font size="6">
<p class="small">
Puede verse que el algoritmo convergió tras 64 iteraciones ofreciendo un stress de 0.071, cifra que puede ser considerada entre “bueno”.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="desarrollo-educativo-de-distintas-zonas-del-mundo-6" class="slide level2">
<h2>Desarrollo educativo de distintas zonas del mundo</h2>
<div id="left">
<pre><code>## 
## Call:
## lm(formula = dist ~ dism)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -0.09232 -0.03865 -0.01007  0.03535  0.17497 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  0.09872    0.01546   6.385  2.2e-08 ***
## dism         0.91158    0.01550  58.811  &lt; 2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.05644 on 64 degrees of freedom
## Multiple R-squared:  0.9818, Adjusted R-squared:  0.9815 
## F-statistic:  3459 on 1 and 64 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
<div id="right">
<pre><code>dist &lt;- cbind(c(fit$dhat))
dism &lt;- cbind(c(fit$confdist))
summary(lm(dist~dism))
</code></pre>
<div align="justify">
<font size="6.5">
<p class="small">
Asimismo el coeficiente de determinación (RSQ) está muy cercano a 1 (0.9818), demostrando así que el ajuste entre disparidades y distancias es casi perfecto.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="desarrollo-educativo-de-distintas-zonas-del-mundo-7" class="slide level2">
<h2>Desarrollo educativo de distintas zonas del mundo</h2>
<div id="left">
<p><img src="clase-4_files/figure-revealjs/unnamed-chunk-20-1.png" width="768" /></p>
</div>
<div id="right">
<pre><code>plot(fit,plot.type=&quot;Shepard&quot;,plot.dim=c(1,2),sphere=TRUE,bubscale=0.1,col=1,
     label.conf=list(label=TRUE,pos=3,col=1,cex=0.8),
     shepard.x=NULL,identify=FALSE,
     type=&quot;p&quot;,pch=20,asp=1,col.hist=NULL)
</code></pre>
<div align="justify">
<font size="6.5">
<p class="small">
<p>El ajuste casi perfecto entre disparidades y distancias se constata también gráficamente usando el gráfico de Shepard.</p>
</p>
<p></font></p>
</div>
</div>
</section>
<section id="desarrollo-educativo-de-distintas-zonas-del-mundo-8" class="slide level2">
<h2>Desarrollo educativo de distintas zonas del mundo</h2>
<div id="left">
<p><img src="clase-4_files/figure-revealjs/unnamed-chunk-21-1.png" width="768" /></p>
</div>
<div id="right">
<div align="justify">
<font size="5">
<p class="small">
Para corroborar que esta solución bidimensional es razonable. De no ser así, si fuera necesario recurrir a cuatro o cinco dimensiones, el MDS no ofrecería demasiada ayuda respecto al análisis de conglomerados, puesto que el análisis gráfico de la solución sería complicado. <br> Para corroborar ensayamos distintas soluciones dimensionales (digamos de 1 a 7) y las representamos en un gráfico las dimensiones en abscisas y el stress en ordenadas. Si la solución bidimensional es válida, el stress debe caer rápidamente hasta alcanzar esa dimensión, disminuyendo mucho menos en dimensiones adicionales. La figura obtenida confirma que la solución bidimensional es la adecuada.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="desarrollo-educativo-de-distintas-zonas-del-mundo-9" class="slide level2">
<h2>Desarrollo educativo de distintas zonas del mundo</h2>
<pre><code>svec &lt;- NULL
for (i in 1:7) {
  svec[i] &lt;- mds(delta=datos, ndim = i, type = &quot;ordinal&quot;)$stress
}

plot(seq(1:7),svec,type=&quot;overplotted&quot;, pch=16, ylab=&quot;Stress&quot;,xlab=&quot;Número de dimensiones&quot;)
</code></pre>
</section>
<section id="desarrollo-educativo-de-distintas-zonas-del-mundo-10" class="slide level2">
<h2>Desarrollo educativo de distintas zonas del mundo</h2>
<div align="justify">
<p>Este código de R permite graficar la representación bidimensional de las regiones usando el MSD.</p>
</div>
<pre><code>plot(fit,plot.type=&quot;confplot&quot;,plot.dim=c(1,2),sphere=TRUE,bubscale=0.1,col=1,
     label.conf=list(label=TRUE,pos=3,col=1,cex=0.8),
     shepard.x=NULL,identify=FALSE,
     type=&quot;p&quot;,pch=20,asp=1,col.hist=NULL)
</code></pre>
</section>
<section id="desarrollo-educativo-de-distintas-zonas-del-mundo-11" class="slide level2">
<h2>Desarrollo educativo de distintas zonas del mundo</h2>
<div id="left">
<p><img src="clase-4_files/figure-revealjs/unnamed-chunk-22-1.png" width="768" /></p>
</div>
<div id="right">
<div align="justify">
<font size="5">
<p class="small">
La figura nos muestra que existen, al menos, tres grupos de regiones con un desarrollo educativo muy diferenciado. Un grupo lo formarían América del Norte (Z1), Asia / Oceanía (Z2) y Europa (Z3). Este grupo vendría caracterizado por contener a los países con mayor desarrollo de sus sistemas educativos. Téngase en cuenta que Z2 incluye solo a aquellos países de Asia y Oceanía más avanzados, como son Japón, Nueva Zelanda o Australia. Interpretamos que estos países son los más avanzados no solo por el sentido común, difícil de aplicar en otro tipo de análisis, sino porque son los más alejados de Z12, que, recordemos, incluía como referencia a aquellos países menos adelantados.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="desarrollo-educativo-de-distintas-zonas-del-mundo-12" class="slide level2">
<h2>Desarrollo educativo de distintas zonas del mundo</h2>
<div id="left">
<p><img src="images/cuadro.JPG" width="100%" /></p>
</div>
<div id="right">
<p><img src="images/geogra.JPG" width="100%" /></p>
</div>
</section>
<section id="desarrollo-educativo-de-distintas-zonas-del-mundo-13" class="slide level2">
<h2>Desarrollo educativo de distintas zonas del mundo</h2>
<div id="left">
<p><img src="clase-4_files/figure-revealjs/unnamed-chunk-25-1.png" width="768" /></p>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
Un grupo intermedio vendría formado por los países euroasiáticos en transición (Z4), América Latina y el Caribe (Z7) y los Estados árabes (Z6), que tendrían un desarrollo educativo intermedio entre los más avanzados y los de menor desarrollo. Estos últimos serían los recogidos en el mapa más cerca de Z12, es decir, Africa subsahariana, Asia Oriental y Oceanía, Asia Meridional e India.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="desarrollo-educativo-de-distintas-zonas-del-mundo-14" class="slide level2">
<h2>Desarrollo educativo de distintas zonas del mundo</h2>
<div id="left">
<p><img src="clase-4_files/figure-revealjs/unnamed-chunk-26-1.png" width="768" /></p>
</div>
<div id="right">
<div align="justify">
<font size="5.5">
<p class="small">
Por qué considerar tres agregados y no más (o menos) en la interpretación. Para ayudar en este tipo de análisis de los gráficos de MDS, Kruskal y Wish (1978) recomiendan complementar esta técnica con otras ya expuestas, como el análisis de conglomerados. Atendiendo a ese dendograma, se han formado los grupos que, como se puede comprobar, sirvió de base para la interpretación que expusimos con anterioridad.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="ejemplo-sobre-psicología-clínica" class="slide level2">
<h2>Ejemplo sobre psicología clínica</h2>
<div align="justify">
<font size="6">
<p class="small">
El conjunto de datos proviene del área de psicología clínica. McNally et al. (2015) recopilaron datos sobre los síntomas del TEPT (trastorno de estrés postraumático) informados por los sobrevivientes del terremoto de Wenchuan en China utilizando la lista de control civil (TEP-C; Weathers et al., 1993). En total, hay 17 ítems de síntomas de trastorno de estrés postraumático escalados en una escala de calificación de 5 puntos (1 … “para nada”; 5 … “extremadamente”). Estamos interesados en representar asociaciones entre el TEPT. los síntomas.
</p>
<p></font></p>
</div>
</section>
<section id="ejemplo-sobre-psicología-clínica-1" class="slide level2">
<h2>Ejemplo sobre psicología clínica</h2>
<pre><code>library(&quot;MPsychoR&quot;)
data(Wenchuan)
head(Wenchuan)
</code></pre>
<pre><code>##   intrusion dreams flash upset physior avoidth avoidact amnesia lossint
## 1         2      2     2     2       3       2        3       2       3
## 2         2      2     2     3       3       3        3       2       3
## 3         2      4     4     4       3       3        3       5       4
## 4         2      1     2     2       1       1        2       2       2
## 5         2      2     2     2       2       2        2       2       3
## 6         4      3     2     2       2       2        3       3       2
##   distant numb future sleep anger concen hyper startle
## 1       2    2      1     3     4      3     4       2
## 2       3    2      2     3     3      2     3       3
## 3       3    2      3     4     4      4     3       4
## 4       1    1      2     2     1      2     3       3
## 5       2    2      2     3     2      3     2       3
## 6       2    2      3     2     3      2     3       2</code></pre>
</section>
<section id="ejemplo-sobre-psicología-clínica-2" class="slide level2">
<h2>Ejemplo sobre psicología clínica</h2>
<div id="left">
<pre><code>
library(&quot;smacof&quot;)
Wdelta &lt;- dist(t(Wenchuan)) ## Euclidean distances
fit.wenchuan1 &lt;- mds(Wdelta, type = &quot;ordinal&quot;) ## MDS fit
fit.wenchuan1
</code></pre>
<pre><code>## 
## Call:
## mds(delta = Wdelta, type = &quot;ordinal&quot;)
## 
## Model: Symmetric SMACOF 
## Number of objects: 17 
## Stress-1 value: 0.133 
## Number of iterations: 35</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
Primero, calculamos las similitudes derivadas utilizando la distancia euclidiana, lo que resulta en una matriz de disimilitud simétrica de 17 × 17. Por un momento, consideremos un nivel de escala ordinal para las diferencias de entrada y ajustemos un MDS ordinal bidimensional. <br> El ajuste de MDS da como resultado un valor de stress de 0.133. El valor del stress en este ejemplo sugiere un ajuste regular del modelo.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="ejemplo-sobre-psicología-clínica-3" class="slide level2">
<h2>Ejemplo sobre psicología clínica</h2>
<div id="left">
<p><img src="clase-4_files/figure-revealjs/unnamed-chunk-29-1.png" width="768" /></p>
</div>
<div id="right">
<pre><code>plot(fit.wenchuan1, main = &quot;Wenchuan MDS&quot;)
</code></pre>
<div align="justify">
<font size="6">
<p class="small">
El gráfico muestra cómo los síntomas de TEPT están relacionados entre sí. Por ejemplo, vemos que “evitar pensar o hablar sobre una experiencia estresante del pasado o evitar tener sentimientos relacionados con ella” (avoidth) y “evitar actividades o situaciones porque le recordaron una experiencia estresante del pasado”(avoidact) están virtualmente en el mismo lugar.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="ejemplo-sobre-psicología-clínica-4" class="slide level2">
<h2>Ejemplo sobre psicología clínica</h2>
<div id="left">
<p><img src="clase-4_files/figure-revealjs/unnamed-chunk-30-1.png" width="768" /></p>
</div>
<div id="right">
<div align="justify">
<font size="5.5">
<p class="small">
También vemos que “sentirse muy molesto cuando algo te recordó una experiencia estresante del pasado?” (upset) y “sentirse emocionalmente adormecido o ser incapaz de tener sentimientos amorosos para las personas cercanas a usted” (numb) son los puntos más lejanos en la primera dimensión, mientras que “problemas para recordar partes importantes de una experiencia estresante del pasado” (amnesia) y “sentirse irritable o tener arrebatos de ira”(anger) son los puntos extremos en la segunda dimensión. Estos pares de síntomas no están relacionados entre sí.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="ejemplo-sobre-psicología-clínica-5" class="slide level2">
<h2>Ejemplo sobre psicología clínica</h2>
<div align="justify">
<font size="6">
<p class="small">
Un error común es interpretar el stress de manera demasiado mecánica al confiar solo en la tabla presentada anteriormente. Esto es problemático debido a que la magnitud del stress depende de la cantidad de objetos <span class="math inline">\(n\)</span> (cuanto más grande es <span class="math inline">\(n\)</span>, mayor es el stress). <br> En las aplicaciones MDS modernas, <span class="math inline">\(n\)</span> puede ser bastante grande. En lugar de utilizar estas reglas generales, podemos considerar enfoques de simulación. Un enfoque antiguo (Spence y Ogilvie, 1973) es simular diferencias aleatorias para <span class="math inline">\(n\)</span> y <span class="math inline">\(p\)</span> fijas y ajustar el modelo MDS correspondiente en estas matrices. Esto conduce a <code>random stress norms</code>.
</p>
<p></font></p>
</div>
</section>
<section id="ejemplo-sobre-psicología-clínica-6" class="slide level2">
<h2>Ejemplo sobre psicología clínica</h2>
<div id="left">
<pre><code>set.seed(123)
rsvec &lt;- randomstress(n = attr(Wdelta, &quot;Size&quot;), ndim = 2,
                      nrep = 500, type = &quot;ordinal&quot;)
mean(rsvec)
mean(rsvec) - 2*sd(rsvec)
</code></pre>
<pre><code>## [1] 0.2770934</code></pre>
<pre><code>## [1] 0.2548536</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="6">
<p class="small">
El llamado <code>randomstress</code> da 500 valores de stress aleatorios. Estos estándares de stress representan un punto de referencia de “mal ajuste”. Nuestra solución debe estar claramente por debajo del stress aleatorio promedio. A menudo, en la literatura, los valores de stress observados se consideran “significativos” si son más pequeños que el límite de estrés aleatorio inferior 2 × sd, que es claramente el caso en nuestro ejemplo (el estrés fue 0.133).
</p>
<p></font></p>
</div>
</div>
</section>
<section id="ejemplo-sobre-psicología-clínica-7" class="slide level2">
<h2>Ejemplo sobre psicología clínica</h2>
<div id="left">
<pre><code>set.seed(123)
permmds &lt;- permtest(fit.wenchuan1, data = Wenchuan,
                    method.dat = &quot;euclidean&quot;, nrep = 500,
                    verbose = FALSE)
permmds
</code></pre>
<pre><code>## 
## Call: permtest.smacof(object = fit.wenchuan1, data = Wenchuan, method.dat = &quot;euclidean&quot;, 
##     nrep = 500, verbose = FALSE)
## 
## SMACOF Permutation Test
## Number of objects: 17 
## Number of replications (permutations): 500 
## 
## Observed stress value: 0.133 
## p-value: &lt;0.001</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="5.5">
<p class="small">
Un enfoque más preciso es utilizar una prueba de permutación como se describe en Mair et al. (2016). Para las diferencias similares, vuelve a muestrear los datos originales, y para cada matriz de desigualdad resultante, se lleva a cabo un ajuste MDS. <br> Esto proporciona una distribución del estrés bajo el <span class="math inline">\(H_0\)</span>: “el stress / configuración se obtiene de una permutación aleatoria de diferencias”. <br> Como <span class="math inline">\(p&lt;0.05\)</span>, rechazamos el <span class="math inline">\(H_0\)</span> y concluimos que el stress / configuración se obtiene de algo distinto a una permutación aleatoria de diferencias.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="ejemplo-sobre-psicología-clínica-8" class="slide level2">
<h2>Ejemplo sobre psicología clínica</h2>
<div id="left">
<p><img src="clase-4_files/figure-revealjs/unnamed-chunk-33-1.png" width="768" /></p>
</div>
<div id="right">
<pre><code>n &lt;- attr(Wdelta, &quot;Size&quot;)
svec &lt;- NULL
for (i in 1:(n-1)) {
  svec[i] &lt;- mds(Wdelta, ndim = i, type = &quot;ordinal&quot;)$stress
}

plot(seq(1:(n-1)),svec,type=&quot;overplotted&quot;, pch=16, ylab=&quot;Stress&quot;,xlab=&quot;Número de dimensiones&quot;, main=&quot;MDS Scree Plot&quot;)
</code></pre>
<div align="justify">
<font size="5.5">
<p class="small">
Basándonos únicamente en el scree plot, probablemente elegiríamos una solución 3D, pero el stress de la solución 2D tampoco es demasiado malo, como lo juzgan las <code>random stress norms</code>, los resultados de las pruebas de permutación y la tabla de referencia de los valores de stress (considerados aquí como n = 17 es bastante pequeño).
</p>
<p></font></p>
</div>
</div>
</section>
<section id="ejemplo-sobre-psicología-clínica-9" class="slide level2">
<h2>Ejemplo sobre psicología clínica</h2>
<div align="justify">
<font size="6">
<p class="small">
Se sabe que la función de objetivo de estrés es irregular. Por lo tanto, puede suceder fácilmente que terminemos en un mínimo local (es decir, no obtenemos la mejor solución posible). <br> Donde el algoritmo termina al final depende de donde comienza. De forma predeterminada, las funciones en el paquete <code>smacof</code> utilizan una solución de escala clásica (Torgerson, 1952) como configuración inicial. Esta no es necesariamente la mejor opción. El problema mínimo local que incluye una búsqueda sistemática de soluciones iniciales se describe en detalle en Borg y Mair (2017). Aquí utilizamos una estrategia ad hoc simple al probar diferentes inicios aleatorios y verificar si la mejor solución de inicio aleatorio conduce a un valor de estrés más bajo que la configuración predeterminada.
</p>
<p></font></p>
</div>
</section>
<section id="ejemplo-sobre-psicología-clínica-10" class="slide level2">
<h2>Ejemplo sobre psicología clínica</h2>
<div id="left">
<pre><code>## [1] 0.1327943</code></pre>
<pre><code>## [1] 0.1328058</code></pre>
</div>
<div id="right">
<div align="justify">
<font size="5.5">
<p class="small">
A continuación examinamos 100 inicios aleatorios y extraemos los valores de estrés. Vemos que un inicio aleatorio en particular proporcionó un stress ligeramente mejor que nuestra solución original. Dado que la diferencia de estrés es tan mínima, podemos elegir cualquiera de las dos soluciones.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="ejemplo-sobre-psicología-clínica-11" class="slide level2">
<h2>Ejemplo sobre psicología clínica</h2>
<pre><code>set.seed(123)
fit.wenchuan &lt;- NULL ## 100 random starts
for(i in 1:100) {
  fit.wenchuan[[i]] &lt;- mds(Wdelta, type = &quot;ordinal&quot;,
                           init = &quot;random&quot;)
}
## extract the best solution
ind &lt;- which.min(sapply(fit.wenchuan,
                        function(x) x$stress))
fit.wenchuan2 &lt;- fit.wenchuan[[ind]]
fit.wenchuan2$stress ## lowest stress (random start)

fit.wenchuan1$stress ## stress (classical scaling start)
</code></pre>
</section>
<section id="ejemplo-sobre-psicología-clínica-12" class="slide level2">
<h2>Ejemplo sobre psicología clínica</h2>
<div id="left">
<p><img src="clase-4_files/figure-revealjs/unnamed-chunk-35-1.png" width="768" /></p>
</div>
<div id="right">
<pre><code>plot(fit.wenchuan2, plot.type = &quot;Shepard&quot;,
     main = &quot;Shepard Diagram (Ordinal MDS)&quot;)
</code></pre>
<div align="justify">
<font size="6">
<p class="small">
Vemos varios puntos grises alejados de la recta, lo cual explica porque el valor de stress no está en el rango de bueno a excelente.
</p>
<p></font></p>
</div>
</div>
</section>
<section id="ejemplo-sobre-psicología-clínica-13" class="slide level2">
<h2>Ejemplo sobre psicología clínica</h2>
<div id="left">
<p><img src="clase-4_files/figure-revealjs/unnamed-chunk-36-1.png" width="768" /></p>
</div>
<div id="right">
<pre><code>plot(fit.wenchuan2, plot.type = &quot;stressplot&quot;,
     main = &quot;Wenchuan Stress-per-Point&quot;)
</code></pre>
<div align="justify">
<font size="5.5">
<p class="small">
La contribución de cada objeto al stress total se puede calcular fácilmente. Los valores resultantes, que normalmente se informan como porcentajes, se denominan stress por punto (SPP).<br> Podemos pensar en puntos con una alta contribución de SPP de manera similar a los valores atípicos influyentes en la regresión. En nuestro ejemplo, vemos que la “pérdida de interés en actividades que solía disfrutar” (lossint) proporciona una contribución de estrés bastante alta del 12.11%.
</p>
<p></font></p>
</div>
</div>
</section>
    </div>
  </div>

  <script src="clase-4_files/reveal.js-3.3.0.1/lib/js/head.min.js"></script>
  <script src="clase-4_files/reveal.js-3.3.0.1/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,
        // Vertical centering of slides
        center: true,
        // Transition style
        transition: 'fade', // none/fade/slide/convex/concave/zoom
        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom



        // Optional reveal.js plugins
        dependencies: [
          { src: 'clase-4_files/reveal.js-3.3.0.1/plugin/notes/notes.js', async: true },
          { src: 'clase-4_files/reveal.js-3.3.0.1/plugin/zoom-js/zoom.js', async: true },
        ]
      });
    </script>
  <!-- dynamically load mathjax for compatibility with self-contained -->
  <script>
    (function () {
      var script = document.createElement("script");
      script.type = "text/javascript";
      script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
      document.getElementsByTagName("head")[0].appendChild(script);
    })();
  </script>

<script>
  (function() {
    if (window.jQuery) {
      Reveal.addEventListener( 'slidechanged', function(event) {  
        window.jQuery(event.previousSlide).trigger('hidden');
        window.jQuery(event.currentSlide).trigger('shown');
      });
    }
  })();
</script>


  </body>
</html>
